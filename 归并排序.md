[1215. 小朋友排队 - AcWing题库](https://www.acwing.com/problem/content/1217/)



统计交换为单调上升序列至少需要的贡献和



分析：



`pii`记录当前位置和当前值



用一个sum数组记录需要交换的总步数，

`1+2+...+sum=(sum+1)*sum/2`，这是当前位置需要的总贡献



```cpp
void mer_so(int l,int r)
{
    if(l>=r)return;

    int mid=(l+r)/2;

    mer_so(l,mid),mer_so(mid+1,r);

    int k=0,i=l,j=mid+1;

    // i和j都指向下一个位置

    while(i<=mid&&j<=r)
    {
        if(a[i].fi<=a[j].fi)
        {
            sum[a[i].se]+=j-mid-1;  // 对于i来说，j前面的都比它小，和[mid+1,j-1]构成逆序对

            tem[++k]=a[i++];
        }
        else
        {
            sum[a[j].se]+=mid-i+1;   // 对于j来说，i后面的都比它大，和[i,mid]构成逆序对

            tem[++k]=a[j++];
        }
    }

    while(i<=mid)
    {
        sum[a[i].se]+=j-1-mid; // 当前位置和后面全部构成逆序对

        tem[++k]=a[i++];
    }

    while(j<=mid)tem[++k]=a[j++];

    for(int i=l,j=1;i<=r&&j<=k;i++,j++)a[i]=tem[j];
}

void solve()
{
    cin>>n; 

    for(int i=1;i<=n;i++)cin>>a[i].fi,a[i].se=i;

    mer_so(1,n);

    for(int i=1;i<=n;i++)ans+=sum[i]*(sum[i]+1)/2;

    cout<<ans<<endl;
}
```



```cpp
#include <bits/stdc++.h>
#include <functional>

#define alls(a) a.begin(),a.end()
#define emb emplace_back
#define pub push_back
#define pob pop_back
#define puf push_front
#define pof pop_front
#define fi first
#define se second
#define No puts("No")
#define Yes puts("Yes")
#define NO puts("NO")
#define YES puts("YES")

using namespace std;
typedef long long ll;
//typedef __int128 lll; // G++(32位)不支持
typedef unsigned long long ull;
typedef pair<int, int> pii;

const int N = 1e5 + 10;
const int mo = 1e9 + 7;
const int inf = 2e9 + 10;

int n;
pii a[N], tem[N];
ll ans, sum[N];

void mer_so(int l, int r)
{
    if (l >= r)return;

    int mid = (l + r) / 2;

    mer_so(l, mid), mer_so(mid + 1, r);

    int k = 0, i = l, j = mid + 1;

    while (i <= mid && j <= r)
    {
        if (a[i] <= a[j])
        {
            sum[a[i].se] += j - (mid + 1);  // [mid+1,j]都比a[i]更小，a[i]要移动到它们后面

            tem[++k] = a[i++];
        }
        else
        {
            sum[a[j].se] += mid - i + 1;  // [i,mid]都比a[j]更大，a[j]要移动到它们前面

            tem[++k] = a[j++];
        }
    }

    while (i <= mid)
    {
        sum[a[i].se] += j - (mid + 1);  // 将a[i]移动到后面

        tem[++k] = a[i++];
    }

    while (j <= r)tem[++k] = a[j++];

    for (int i = l, j = 1; i <= r && j <= k; i++, j++)a[i] = tem[j];
}

void solve()
{
    cin >> n;

    for (int i = 1; i <= n; i++)
    {
        cin >> a[i].first;

        a[i].second = i;
    }

    mer_so(1, n);

    for (int i = 1; i <= n; i++)  // 记录总移动次数
    {
        ans += (1 + sum[i]) * sum[i] / 2;
    }

    cout << ans << endl;
}

int main()
{
    int t;

    //cin >> t;

    t = 1;

    while (t--)solve();

    return 0;
}
```





[505. 火柴排队 - AcWing题库](https://www.acwing.com/problem/content/507/)



问使得差值平方总和最小，

至少需要交换相邻元素多少次



分析：



目标——对于每个b数组下标1~n找到映射的a数组下标



首先用辅助数组记录当前优先级对应的数组下标，

用a[i]记录当前位置对应的优先级，

通过c数组记录每个优先级对应的a数组原数组下标，

`b[i]=c[b[i]]`，b数组每个下标根据优先级映射到a数组，

最后对b数组进行归并排序



```cpp
void work(int a[])
{
    for(int i=1;i<=n;i++)p[i]=i;

    sort(p+1,p+n+1,[&](int x,int y)
    {
        return a[x]<a[y];
    });

    for(int i=1;i<=n;i++)a[p[i]]=i;  // 记录排完序后每个位置对应的当前下标
}

void mer_so(int l,int r)
{
    if(l>=r)return;

    int mid=(l+r)/2;

    mer_so(l,mid),mer_so(mid+1,r);

    int i=l,j=mid+1,k=0;

    while(i<=mid&&j<=r)
    {
        if(b[i]<=b[j])
        {
            tem[++k]=b[i++];
        }
        else
        {
            tem[++k]=b[j++];

            ans+=mid-i+1;
        }
    }
}

void solve()
{
    cin>>n;

    for(int i=1;i<=n;i++)cin>>a[i]; 
    for(int i=1;i<=n;i++)cin>>b[i];

    work(a),work(b);

    for(int i=1;i<=n;i++)c[a[i]]=i;  // 当前排序后每个位置对应的原来位置的下标

    for(int i=1;i<=n;i++)b[i]=c[b[i]];  // b数组每个位置的下标应该和a数组哪个位置匹配

    merge(1,n);

    cout<<ans<<endl;
}
```



```cpp
#include <bits/stdc++.h>
#include <functional>

#define alls(a) a.begin(),a.end()
#define emb emplace_back
#define pub push_back
#define pob pop_back
#define puf push_front
#define pof pop_front
#define fi first
#define se second
#define No puts("No")
#define Yes puts("Yes")
#define NO puts("NO")
#define YES puts("YES")

using namespace std;
typedef long long ll;
//typedef __int128 lll; // G++(32位)不支持
typedef unsigned long long ull;
typedef pair<int, int> pii;

const int N = 1e5 + 10;
const int mo = 99999997;
const int inf = 2e9 + 10;

ll ans;
int n, a[N], b[N], tem[N];
int p[N], c[N];

void work(int a[])
{
    for (int i = 1; i <= n; i++)p[i] = i;

    sort(p + 1, p + n + 1, [&](int x, int y)
    {
        return a[x] < a[y];
    });

    for (int i = 1; i <= n; i++)a[p[i]] = i;  // 存放每个位置排完序之后的位次
}

void mer_so(int l, int r)
{
    if (l >= r)return;

    int mid = (l + r) / 2;

    mer_so(l, mid), mer_so(mid + 1, r);

    int k = 0, i = l, j = mid + 1;

    while (i <= mid && j <= r)
    {
        if (b[i] <= b[j])
        {
            tem[++k] = b[i++];
        }
        else
        {
            tem[++k] = b[j++];

            (ans += (mid - i + 1)) %= mo;
        }
    }

    while (i <= mid)tem[++k] = b[i++];

    while (j <= r)tem[++k] = b[j++];

    for (int i = 1, j = l; i <= k && j <= r; i++, j++)b[j] = tem[i];
}

void solve()
{
    cin >> n;

    for (int i = 1; i <= n; i++)cin >> a[i];

    for (int i = 1; i <= n; i++)cin >> b[i];

    work(a), work(b);

    for (int i = 1; i <= n; i++)c[a[i]] = i;  // 存放每个位次对应的a的位置

    for (int i = 1; i <= n; i++)b[i] = c[b[i]];  // 存放每个b位置对应的a位置

    mer_so(1, n);

    cout << ans << endl;
}

int main()
{
    int t;

    //cin >> t;

    t = 1;

    while (t--)solve();

    return 0;
}#include <bits/stdc++.h>
#include <functional>

#define alls(a) a.begin(),a.end()
#define emb emplace_back
#define pub push_back
#define pob pop_back
#define puf push_front
#define pof pop_front
#define fi first
#define se second
#define No puts("No")
#define Yes puts("Yes")
#define NO puts("NO")
#define YES puts("YES")

using namespace std;
typedef long long ll;
//typedef __int128 lll; // G++(32位)不支持
typedef unsigned long long ull;
typedef pair<int, int> pii;

const int N = 1e5 + 10;
const int mo = 99999997;
const int inf = 2e9 + 10;

ll ans;
int n, a[N], b[N], tem[N];
int p[N], c[N];

void work(int a[])
{
    for (int i = 1; i <= n; i++)p[i] = i;

    sort(p + 1, p + n + 1, [&](int x, int y)
    {
        return a[x] < a[y];
    });

    for (int i = 1; i <= n; i++)a[p[i]] = i;  // 存放每个位置排完序之后的位次
}

void mer_so(int l, int r)
{
    if (l >= r)return;

    int mid = (l + r) / 2;

    mer_so(l, mid), mer_so(mid + 1, r);

    int k = 0, i = l, j = mid + 1;

    while (i <= mid && j <= r)
    {
        if (b[i] <= b[j])
        {
            tem[++k] = b[i++];
        }
        else
        {
            tem[++k] = b[j++];

            (ans += (mid - i + 1)) %= mo;
        }
    }

    while (i <= mid)tem[++k] = b[i++];

    while (j <= r)tem[++k] = b[j++];

    for (int i = 1, j = l; i <= k && j <= r; i++, j++)b[j] = tem[i];
}

void solve()
{
    cin >> n;

    for (int i = 1; i <= n; i++)cin >> a[i];

    for (int i = 1; i <= n; i++)cin >> b[i];

    work(a), work(b);

    for (int i = 1; i <= n; i++)c[a[i]] = i;  // 存放每个位次对应的a的位置

    for (int i = 1; i <= n; i++)b[i] = c[b[i]];  // 存放每个b位置对应的a位置

    mer_so(1, n);

    cout << ans << endl;
}

int main()
{
    int t;

    //cin >> t;

    t = 1;

    while (t--)solve();

    return 0;
}
```





## 归并排序求逆序对数量：

## 归并排序是在两半已经有序的前提下排序，

## 可以根据现有的有序数量直接求逆序对的数量



[788. 逆序对的数量 - AcWing题库](https://www.acwing.com/problem/content/790/)

[107. 超快速排序 - AcWing题库](https://www.acwing.com/problem/content/109/)



分析：



```cpp
void mer_so(int l,int r)
{
    if(l>=r)return;

    int mid=(l+r)/2;

    mer_so(l,mid),mer_so(mid+1,r);

    int k=0,i=l,j=mid+1;

    while(i<=mid&&j<=r)
    {
        if(a[i]<=a[j])
        {
            tem[++k]=a[i++];
        }
        else
        {
            tem[++k]=a[j++];

            ans+=mid-i+1;  // a[i]>a[j],[i,mid]都>a[j]，逆序对一共有mid-i+1对
        }
    }

    while(i<=mid)tem[++k]=a[i++];  // 有一方取完了，没有可以计数的逆序对了

    while(j<=r)tem[++k]=a[j++];

    for(int i=l,j=1;j<=k&&i<=r;i++,j++)a[i]=tem[j];
}

void solve()
{
    cin>>n;

    for(int i=1;i<=n;i++)cin>>a[i];

    mer_so(1,n);

    cout<<ans<<endl;
}
```



```cpp
#include <bits/stdc++.h>
#include <functional>

#define alls(a) a.begin(),a.end()
#define emb emplace_back
#define pub push_back
#define pob pop_back
#define puf push_front
#define pof pop_front
#define fi first
#define se second
#define No puts("No")
#define Yes puts("Yes")
#define NO puts("NO")
#define YES puts("YES")

using namespace std;
typedef long long ll;
//typedef __int128 lll; // G++(32位)不支持
typedef unsigned long long ull;
typedef pair<int, int> pii;

const int N = 1e5 + 10;
const int mo = 1e9 + 7;
const int inf = 2e9 + 10;

int n, a[N], tem[N];
ll ans;

void mer_so(int l, int r)
{
    if (l >= r)return;

    int mid = (l + r) / 2;

    mer_so(l, mid);
    mer_so(mid + 1, r);

    int k = 0, i = l, j = mid + 1;

    while (i <= mid && j <= r)
    {
        if (a[i] <= a[j])tem[++k] = a[i++];
        else
        {
            ans += mid - i + 1;  // [i,mid]全部不满足要求>a[j]

            tem[++k] = a[j++];
        }
    }

    while (i <= mid)tem[++k] = a[i++];

    while (j <= r)tem[++k] = a[j++];

    for (int i = l, j = 1; i <= r && j <= k; i++, j++)a[i] = tem[j];
}

void solve()
{
    cin >> n;

    for (int i = 1; i <= n; i++)cin >> a[i];

    mer_so(1, n);

    cout << ans << endl;
}

int main()
{
    int t;

    //cin >> t;

    t = 1;

    while (t--)solve();

    return 0;
}
```



```cpp
#include <bits/stdc++.h>
#include <functional>

#define alls(a) a.begin(),a.end()
#define emb emplace_back
#define pub push_back
#define pob pop_back
#define puf push_front
#define pof pop_front
#define fi first
#define se second
#define No puts("No")
#define Yes puts("Yes")
#define NO puts("NO")
#define YES puts("YES")

using namespace std;
typedef long long ll;
//typedef __int128 lll; // G++(32位)不支持
typedef unsigned long long ull;
typedef pair<int, int> pii;

const int N = 5e5 + 10;
const int mo = 1e9 + 7;
const int inf = 2e9 + 10;

int n, a[N], tem[N];
ll ans;

void mer_so(int l, int r)
{
    if (l >= r)return;

    int mid = (l + r) / 2;

    mer_so(l, mid), mer_so(mid + 1, r);

    int k = 0, i = l, j = mid + 1;

    while (i <= mid && j <= r)
    {
        if (a[i] <= a[j])
        {
            tem[++k] = a[i++];
        }
        else
        {
            ans += mid - i + 1;

            tem[++k] = a[j++];
        }
    }

    while (i <= mid)tem[++k] = a[i++];
    while (j <= r)tem[++k] = a[j++];

    for (int i = l, j = 1; i <= r && j <= k; i++, j++)
    {
        a[i] = tem[j];
    }
}

void solve()
{
    while (cin >> n, n)
    {
        for (int i = 1; i <= n; i++)cin >> a[i];

        ans = 0;

        mer_so(1, n);

        cout << ans << endl;
    }
}

int main()
{
    int t;

    //cin >> t;

    t = 1;

    while (t--)solve();

    return 0;
}
```





## 归并排序：

## O(logN)

## 在左右两半已经排序好的前提下合并，

## 不断分成左右两边，不断将左右两边合并



[787. 归并排序 - AcWing题库](https://www.acwing.com/problem/content/789/)



分析：



用一个辅助数组进行排序的复原，k记录当前填充了多少数字



```cpp
void mer_so(int l,int r)
{
    if(l>=r)return;

    int mid=(l+r)/2,k=0;

    mer_so(l,mid),mer_so(mid+1,r);

    int i=l,j=mid+1;

    while(i<=mid&&j<=r)  // 合并
    {
        if(a[i]<a[j])tem[++k]=a[i++];
        else tem[++k]=a[j++];
    }

    while(i<=mid)tem[++k]=a[i++];
    while(j<=r)tem[++k]=a[j++];

    for(int i=l,j=1;i<=r&&j<=k;i++,j++)a[i]=tem[j];  // 复原
}

void solve()
{
    cin>>n; 

    for(int i=1;i<=n;i++)cin>>a[i]; 

    mer_so(1,n);

    for(int i=1;i<=n;i++)cout<<a[i]<<' ';
}
```



```cpp
#include <bits/stdc++.h>
#include <functional>

#define alls(a) a.begin(),a.end()
#define emb emplace_back
#define pub push_back
#define pob pop_back
#define puf push_front
#define pof pop_front
#define fi first
#define se second
#define No puts("No")
#define Yes puts("Yes")
#define NO puts("NO")
#define YES puts("YES")

using namespace std;
typedef long long ll;
//typedef __int128 lll; // G++(32位)不支持
typedef unsigned long long ull;
typedef pair<int, int> pii;

const int N = 1e5 + 10;
const int mo = 1e9 + 7;
const int inf = 2e9 + 10;

int n, a[N], tem[N];

void mer_so(int l, int r)
{
    if (l >= r)return;

    int k = 0, mid = (l + r) / 2;

    mer_so(l, mid), mer_so(mid + 1, r);

    int i = l, j = mid + 1;

    while (i <= mid && j <= r)
    {
        if (a[i] < a[j])tem[++k] = a[i++];
        else tem[++k] = a[j++];
    }

    while (i <= mid)tem[++k] = a[i++];
    while (j <= r)tem[++k] = a[j++];

    for (int i = l, j = 1; i <= r && j <= k; i++, j++)
    {
        a[i] = tem[j];
    }
}

void solve()
{
    cin >> n;

    for (int i = 1; i <= n; i++)cin >> a[i];

    mer_so(1, n);

    for (int i = 1; i <= n; i++)cout << a[i] << ' ';
}

int main()
{
    int t;

    //cin >> t;

    t = 1;

    while (t--)solve();

    return 0;
}
```
