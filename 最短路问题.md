[L3-005 垃圾箱分布 - 团体程序设计天梯赛-练习集](https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=994805052131098624&page=1)



垃圾箱的位置选在到所有居民点的最短距离最长的地方，

保证每个居民点都距离它<=d



分析：



mp存放每个字符串对应的数字编号，

对每个垃圾箱求dijk，检查是否合法，合法存放在ans数组，

sort ans数组，ans[0]即为答案



```cpp
struct node
{
    int id;
    int minn;
    double ave;

    bool operator<(const &w)
    {
        if(minn>w.minn)return true;
        else if(minn==w.minn&&ave<w.ave)return true;
        else if(minn==w.minn&&ave==w.ave&&id<w.id)return true;
        else return false;
    }
};

void dijk(int x)
{
    priority_queue<pii,vector<pii>,greater<pii>>q;

    q.push({0,x});    // 最短路径更新别的路径

    for(int i=1;i<=n+m;i++)f[i]=false,dist[i]=inf;

    dist[x]=0;

    while(!q.empty())
    {
        t=q.top(); q.pop();

        u=t.second;

        if(!st[u])
        {
            st[u]=true;

            for(auto v:e[u])
            {
                if(dist[u]+v.se<dist[v.fi])
                {
                    dist[v.fi]=dist[u]+v.se; q.push({dist[v.fi],v.fi});
                }
            }
        }
    }
}

void solve()
{
    cin>>n>>m>>k>>d;

    for(int i=1;i<=n;i++)mp[to_string(i)]=i;

    for(int i=1;i<=m;i++)mp["G"+to_string(i)]=i+n;

    for(int i=1;i<=k;i++)
    {    
        cin>>s1>>s2>>x;
        e[mp[s1]].push_back({mp[s2],x});
        e[mp[s2]].push_back({mp[s1],x});
    }

    for(int i=n+1;i<=n+m;i++)
    {
        dijk(i);

        f=true;
        sum=0,minn=inf;

        for(int j=1;j<=n;j++)
        {
            if(dist[j]>d)
            {
                f=false; break;
            }
            sum+=dist[j]; minn=min(minn,dist[j]);
        }

        if(f==false)continue;
        
        ans.push_back({i,minn,sum*1.0/n});
    }

    if(ans.empty())puts("No Solution");
    else
    {
        sort(alls(ans));

        cout<<"G"<<ans[0].id-n<<endl;

        printf("%.1f ",(double)ans[0].minn);

        // 1位小数的四舍五入
        if(ans[0].ave*10-(int)(ans[0].ave*10)>=0.5)ans[0].ave*=10,ans[0].ave+=1;
        else ans[0].ave*=10;

        printf("%.1f",(int)ans[0].ave/10.0);
    }
}
```



> 四位小数四舍五入：
> 
> 1. 看第5位是否>=0.5
> 
> 2. *10000，加/不加1
> 
> ```cpp
> if(a*10000-(int)(a*10000)>=0.5)a*=10000,a+=1
> else a*=10000;
> 
> printf("%.4f",(int)a/10000.0);
> ```







[7-3 打怪升级 - 2021 RoboCom 世界机器人开发者大赛-本科组（初赛） (pintia.cn)](https://pintia.cn/problem-sets/1446838676759703552/exam/problems/type/7?problemSetProblemId=1446838732288094210&page=0)



选择一个到任一堡垒花费能量最大值最小的堡垒，

最后分别给出从当前堡垒出发到k个堡垒的最优路线，

以及对应的花费能量和武器价值



分析：



pre数组记录当前路径上当前点之前的结点，

方便输出的时候进行回溯



dijk求出发堡垒，用dfs输出路线



dijk：

每次找一个没有被找过的点作为中间点用于更新其他点



```cpp
void dfs(int u)
{
    if(pre[u]==u)    // 回溯到起点，开始输出
    {
        cout<<u; return;
    }

    dfs(pre[u]);

    cout<<"->"<<u;
}

void dijk(int u)
{
    memset(dist,0x3f,sizeof(dist));
    memset(st,0,sizeof(st));
    memset(val,0,sizeof(val));
    memset(pre,0,sizeof(pre));

    dist[u]=0; val[u]=0; pre[u]=u;

    int t=-1;

    for(int i=1;i<=n;i++)
    {
        t=-1;

        for(int j=1;j<=n;j++)
        {
            if(!st[j]&&(t==-1||dist[t]>dist[j]))t=j;
        }

        st[t]=true;

        for(int j=1;j<=n;j++)
        {
            if(dist[j]>dist[t]+dist[t][j])    // 更短路
            {
                dist[j]=dist[t]+dist[t][j];
                val[j]=val[t]+w[t][j];
                pre[j]=t;
            }
            else if(dist[j]==dist[t]+dist[t][j])    // 相同长度但是价值更高
            {
                if(val[j]<val[t]+w[t][j])
                {
                    val[j]=val[t]+w[t][j];
                    pre[j]=t;
                }
            }
        }
    }
}

void solve()
{
    memset(g,0x3f,sizeof(g));

    cin>>n>>m;

    for(int i=1;i<=m;i++)
    {
        cin>>a>>b>>vv>>ww;

        g[a][b]=g[b][a]=vv;
        w[a][b]=w[b][a]=ww;
    }

    len=inf,idx=1;

    for(int i=1;i<=n;i++)
    {
        dijk(i);

        maxx=0;

        for(int j=1;j<=n;j++)maxx=max(maxx,dist[j]);

        if(maxx<len)
        {
            len=maxx; idx=i;
        }
    }

    cout<<idx<<endl;

    dijk(idx);

    cin>>k;

    for(int i=1;i<=k;i++)
    {
        cin>>x;

        dfs(x);

        cout<<endl<<dist[x]<<' '<<val[x]<<endl;
    }
}
```



```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e3 + 10;
const int inf = 0x3f3f3f3f;

int n, m, k;
int a, b, vv, ww;

int maxx;
int idx, len;

// dist数组存放最短距离
// val数组存放当前最短路情况下最大价值
// pre数组存放当前点路径的前一个位置

int g[N][N], w[N][N];
int dist[N], val[N], pre[N];
bool st[N];

void dfs(int x)
{
    if (pre[x] == x)
    {
        cout << x;

        return;
    }

    dfs(pre[x]);    // 递归从第一个点开始输出

    cout << "->" << x;
}

void dijk(int u)
{
    memset(dist, 0x3f, sizeof(dist));
    memset(st, 0, sizeof(st));
    memset(val, 0, sizeof(val));
    memset(pre, 0, sizeof(pre));

    pre[u] = u;
    dist[u] = 0;
    val[u] = 0;

    int t;

    for (int i = 1; i <= n; i++)
    {
        t = -1;

        for (int j = 1; j <= n; j++)    // 找到最近的点
        {
            if (!st[j] && (t == -1 || dist[j] < dist[t]))t = j;
        }

        st[t] = true;

        for (int j = 1; j <= n; j++)    // 用最近的点作为中间点更新
        {
            if (dist[j] > dist[t] + g[t][j])    // 更近
            {
                dist[j] = dist[t] + g[t][j];

                val[j] = val[t] + w[t][j];    // 路径变了，总价值也改变

                pre[j] = t;                    // 中转点作为前一个点
            }
            else if (dist[j] == dist[t] + g[t][j])
            {
                if (val[j] < val[t] + w[t][j])    // 相同距离下价值更高
                {
                    val[j] = val[t] + w[t][j];

                    pre[j] = t;
                }
            }
        }
    }
}

int main()
{
    cin >> n >> m;

    memset(g, 0x3f, sizeof(g));

    for (int i = 1; i <= m; i++)
    {
        cin >> a >> b >> vv >> ww;

        g[a][b] = g[b][a] = vv;
        w[a][b] = w[b][a] = ww;
    }

    len = inf;
    idx = 1;

    for (int i = 1; i <= n; i++)
    {
        dijk(i);        // 从当前堡垒出发求最短路

        maxx = 0;

        // 找到攻克堡垒的最大能量值

        for (int j = 1; j <= n; j++)maxx = max(maxx, dist[j]);

        if (maxx < len)
        {
            len = maxx;

            idx = i;    // 更新空降堡垒
        }
    }

    cout << idx << endl;

    cin >> k;

    dijk(idx);

    for (int i = 1; i <= k; i++)
    {
        cin >> a;

        dfs(a);

        cout << endl << dist[a] << ' ' << val[a] << endl;
    }

    return 0;
}
```





[L2-001 紧急救援 - 团体程序设计天梯赛-练习集 (pintia.cn)](https://pintia.cn/problem-sets/994805046380707840/exam/problems/994805073643683840?type=7&page=0)



分析：



用pre数组记录路径



每次通过没被更新的点更新最小距离

1. 如果当前距离更小，直接用cnt更新方案数，增加num

2. 当前距离相同
   
   1. 合并方案数
   
   2. 选择最大num数目，相同距离路径只能选一条
      
      

```cpp
void dijk()
{
    dist[s]=0; 

    cnt[s]=1; pre[s]=s; num[s]=p[s];  // 初始方案数为1    

    for(int i=0;i<n;i++)  // 轮数
    {
        cur=-1;

        for(int j=0;j<n;j++)
        {
            if(!st[j&&(cur==-1||dist[cur]>dist[j]))cur=j;
        }

        st[cur]=true;

        for(int j=0;j<n;j++)
        {
            if(dist[j]>dist[cur]+g[cur][j])
            {
                dist[j]=dist[cur]+g[cur][j];  // 更新最短路径

                pre[j]=cur;  // 走到当前节点

                cnt[j]=cnt[cur];

                num[j]=num[cur]+p[j];  // 当前总人数
            }
            else if(dist[j]==dist[cur]+g[cur][j])
            {
                cnt[j]+=cnt[cur];

                num[j]=max(num[j],num[cur]+p[j]);  // 长度相同前提下，人数取最大

                if(num[j]==num[cur]+p[j])
                {
                    pre[j]=cur;
                }
            }
        }
    }
}

void solve()
{
    cin>>n>>m>>s>>d;

    for(int i=0;i<n;i++)cin>>p[i];

    for(int i=0;i<n;i++)for(int j=0;j<n;j++)
    {
        if(i==j)g[i][j]=0; else g[i][j]=0x3f3f3f3f;
    }

    for(int i=1;i<=m;i++)
    {
        cin>>a>>b>>c; g[a][b]=g[b][a]=min(g[a][b],c);
    }

    dijk();

    cout<<cnt[d]<<' '<<num[d]<<endl;

    vector<int>ans;

    cur=d;  // 从终点往前找

    while(cur!=s)
    {
        ans.push_back(cur); cur=pre[cur];
    }

    ans.push_back(s);

    sort(alls(ans));

    for(int i=0;i<ans.size()-1;i++)cout<<ans[i]<<' ';

    cout<<ans.back();
}
```



```cpp
#include <bits/stdc++.h>

#define alls(x) x.begin(),x.end()

using namespace std;

const int N = 510;

int a, b, c;
int n, m, s, d;
int g[N][N],dist[N];
int p[N], cnt[N], num[N], pre[N];
bool st[N];

void dijk()
{
    memset(dist, 0x3f, sizeof(dist));

    dist[s] = 0;

    cnt[s] = 1;  // 初始出发方案数为1
    pre[s] = s;
    num[s] = p[s];  // 当前路段救援队初始总数

    int cur = -1;

    for (int i = 0; i < n; i++)
    {
        cur = -1;

        for (int j = 0; j < n; j++)  // 找到最短且没有被去过的路
        {
            if (!st[j] && (cur == -1 || dist[cur] > dist[j]))cur = j;
        }

        st[cur] = true;

        // 1. 当前路没被走过
        // 2. 当前路更短
        // 3. 当前路一样长，增加固定长度的方案数，如果当前这条道路交汇人数更多选择当前这条路

        for (int j = 0; j < n; j++)
        {
            if (!st[j] && dist[j] > dist[cur] + g[cur][j])
            {
                dist[j] = dist[cur] + g[cur][j];

                cnt[j] = cnt[cur];  // 选择途径当前方案的方案数

                pre[j] = cur;

                num[j] = num[cur] + p[j];
            }
            else if (!st[j] && dist[j] == dist[cur] + g[cur][j])
            {
                cnt[j] += cnt[cur];

                if (num[j] < num[cur] + p[j])
                {
                    num[j] = num[cur] + p[j];

                    pre[j] = cur;
                }
            }
        }
    }
}

int main()
{
    cin >> n >> m >> s >> d;

    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (i == j)g[i][j] = 0;
            else g[i][j] = 0x3f3f3f3f;
        }
    }

    for (int i = 0; i < n; i++)cin >> p[i];  // 救援队队数

    while (m--)
    {
        cin >> a >> b >> c;

        g[a][b] = g[b][a] = min(g[a][b], c);
    }

    dijk();

    cout << cnt[d] << ' ' << num[d] << endl;

    vector<int>ans;

    int cur = d;

    while (cur != s)
    {
        ans.push_back(cur);

        cur = pre[cur];
    }

    ans.push_back(s);

    reverse(alls(ans));

    for (int i = 0; i < ans.size() - 1; i++)cout << ans[i] << ' ';

    cout << ans.back();

    return 0;
}
```



## Dijkstra：

求每个节点到节点1的最短路径，

一共n轮，每轮循环找当前没被遍历过且距离节点1最近的结点，

通过当前节点更新每个节点到节点1的最短距离



[P1553 - [蓝桥杯2021初赛] 路径 - New Online Judge (ecustacm.cn)](http://oj.ecustacm.cn/problem.php?id=1553)



分析：



Floyd是将中间节点k放在最外层循环，

`dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);`

$O(n^3)$



Dijkstra是每次找到距离节点1最近的结点更新，

通过每轮没被遍历过的最近结点更新其他节点到节点1的最短距离

$O(n^2)$

```cpp
int lcm(int a,int b)
{
    return a*b/__gcd(a,b);
}

void solve()
{
    n=2021;

    memset(dist,0x3f,sizeof(dist));

    dist[1]=0;

    for(int i=1;i<=n;i++)
    {
        cur=0;

        for(int j=1;j<=n;j++)
        {
            if(!st[j]&&(!cur||dist[cur]>dist[j]))cur=j;
        }

        st[cur]=true;

        for(int j=max(1,cur-21);j<=min(n,cur+21);j++)
        {
            dist[j]=min(dist[j],dist[cur]+lcm(cur,j));  // 用节点cur来更新节点j
        }
    }

    cout<<dist[n]<<endl;
}
```



dp，从节点1出发转移每个符合要求节点的最短路

$O(n)$

```cpp
int lcm(int a,int b)
{
    return a*b/__gcd(a,b);
}

void solve()
{
    n=2021;

    memset(f,0x3f,sizeof(f));

    f[1]=0;

    for(int i=1;i<=n;i++)
    {
        for(int j=max(1,i-21);j<=min(n,i+21);j++)
        {
           f[j]=min(f[j],f[i]+lcm(i,j)); 
        }
    }

    cout<<f[n]<<endl;
}
```



```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int N = 2030;

int n = 2021;
int cur;
ll dist[N];
bool st[N];

ll gcd(ll a, ll b)
{
    return b ? gcd(b, a % b) : a;
}

ll lcm(ll a, ll b)
{
    return a * b / gcd(a, b);
}

int main()
{
    memset(dist, 0x3f, sizeof(dist));

    dist[1] = 0;

    for (int i = 1; i <= n; i++)
    {
        cur = 0;

        for (int j = 1; j <= n; j++)
        {
            if (!st[j] && (!cur || dist[j] < dist[cur]))cur = j;  // 找到和点1最近的边
        }

        st[cur] = true;

        for (int j = max(1, cur - 21); j <= min(n, cur + 21); j++)
        {
            dist[j] = min(dist[j], dist[cur] + lcm(cur, j));
        }
    }

    cout << dist[n] << endl;

    return 0;
}
```



```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 2030;

int n = 2021;
int f[N];

int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }
int lcm(int a, int b) { return a * b / gcd(a, b); }

int main()
{
    memset(f, 0x3f, sizeof(f));

    f[1] = 0;

    for (int i = 1; i <= n;i++)
    {
        for (int j = max(1, i - 21); j <= min(n, i + 21); j++)
        {
            f[j] = min(f[j], f[i] + lcm(i, j));
        }
    }

    cout << f[n] << endl;

    return 0;
}
```
