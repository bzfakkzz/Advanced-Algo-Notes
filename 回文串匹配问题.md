[L2-008 最长对称子串 - 团体程序设计天梯赛-练习集 (pintia.cn)](https://pintia.cn/problem-sets/994805046380707840/exam/problems/994805067704549376?type=7&page=1)



分析：



判断母串本身是否为回文串，

马拉车算法处理出不含母串本身的子串回文串长度，找最大值



```cpp
void solve()
{
    cin>>s;

    x=s;

    reverse(x.begin(),x.end());

    if(x==s)
    {
        cout<<x.size(); return;
    }

    x="$";

    for(int i=0;i<s.size();i++)
    {
        x+=s[i]; x+='#';
    }

    x+='.';

    for(int i=1;i<=x.size();i++)
    {
        if(maxx>2*id-i)len[i]=min(len[2*id-i],maxx-i);  // 对称位置在蘑菇内
        else len[i]=1;

        while(x[i-len[i]-1]==x[i+len[i]+1])len[i]++;  // 从已经延伸过的起点延伸

        if(i+len[i]>maxx)  // 最远能延伸的长度超过了当前最长长度
        {
            maxx=i+len[i];  // 蘑菇能延伸的最长长度

            id=i;  // 对称中心
        }
    }

    for(int i=1;i<x.size();i++)ans=max(maxx,len[i]);

    cout<<ans;
}
```



```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 2e3 + 10;

string s, ss, x;
int maxx, id;
int len[N], ans;

int main()
{
    getline(cin, s);

    ss = s;

    reverse(ss.begin(), ss.end());

    if (ss == s)
    {
        cout << s.size();

        return 0;
    }

    x = "$";

    for (int i = 0; i < s.size(); i++)
    {
        x += s[i];

        x += '#';
    }

    x += '.';

    for (int i = 1; i < x.size(); i++)
    {
        if (maxx > 2 * id - i)len[i] = min(len[2 * id - i], maxx - i);
        else len[i] = 1;

        while (x[i - len[i] - 1] == x[i + len[i] + 1])len[i]++;

        if (i + len[i] > maxx)
        {
            maxx = i + len[i];

            id = i;
        }
    }

    for (int i = 0; i < x.size(); i++)ans = max(ans, len[i]);

    cout << ans;

    return 0;
}
```



## 判断回文串：

正反字符串哈希

```cpp
const int p=131;

void ini()
{
    pp[0]=1;

    for(int i=1;i<=n;i++)
    {
        h[i]=h[i-1]*p+s[i];

        pp[i]=pp[i-1]*p;
    }
}

void get(int l,int r)
{
    return h[r]-h[l-1]*pp[r-l+1];  // r-(l-1)=r-l+1 减去前面的累加值 获取当前子串s[l,r]的哈希值
}
```



[Problem - E - Codeforces](https://codeforces.com/contest/1951/problem/E)



分析：



如果当前字符串非回文串，直接输出



如果当前字符串为回文串，

只要不是形如aaaaa，总能分为两个非回文串

abababa -> a bababa

acbbca -> a cbbca



```cpp
const int p=131;

void ini()
{
    p1[0]=1;

    for(int i=1;i<=n;i++)
    {
        h1[i]=h1[i-1]*p+s[i];

        p1[i]=p2[i-1]*p;
    }
}

void inii()
{
    p2[0]=1;

    for(int i=1;i<=n;i++)
    {
        h2[i]=h2[i-1]*p+ss[i];

        p2[i]=p2[i-1]*p;
    }
}

void get(int l,int r)
{
    return h1[r]-h1[l-1]*p1[r-l+1];
}

void gett(int l,int r)
{
    return h2[r]-h2[l-1]*p2[r-l+1];
}

void solve()
{
    cin>>s;

    n=s.size();

    ss=s;

    reverse(alls(ss));

    ss=" "+ss;

    ini(),inii();

    if(s!=ss)
    {
        YES; puts("1"); cout<<s<<endl;
    }
    else
    {
        for(int i=1;i<=n-1;i++)
        {
            l1=1,r1=i; l2=i+1,r2=n;

            if(get(l1,r1)!=get(n+1-r1,n+1-l1)&&get(l2,r2)!=get(n+1-r2,n+1-l2))
            {
                YES;

                puts("2");

                for(int i=l1;i<=r1;i++)cout<<s[i]; cout<<' ';

                for(int i=l2;i<=r2;i++)cout<<s[i];

                puts("");

                return;
            }
        }

        NO;
    }
}
```



```cpp
#include <bits/stdc++.h>
#include <functional>
 
#define alls(a) a.begin(),a.end()
#define emb emplace_back
#define pub push_back
#define pob pop_back
#define puf push_front
#define pof pop_front
#define fi first
#define se second
#define No puts("No")
#define Yes puts("Yes")
#define NO puts("NO")
#define YES puts("YES")
 
using namespace std;
typedef long long ll;
//typedef __int128 lll; // G++(32位)不支持
typedef unsigned long long ull;
typedef pair<int, int> pii;
 
const int N = 1e6 + 10;
const int mo = 1e9 + 7;
const int inf = 2e9 + 10;
const int p = 131;
 
int n;
string s, t;
ull h1[N], p1[N], h2[N], p2[N];
 
void ini()
{
    p1[0] = 1;
 
    for (int i = 1; i <= n; i++)
    {
        h1[i] = h1[i - 1] * p + s[i];
 
        p1[i] = p1[i - 1] * p;
    }
}
 
void inii()
{
    p2[0] = 1;
 
    for (int i = 1; i <= n; i++)
    {
        h2[i] = h2[i - 1] * p + t[i];
 
        p2[i] = p2[i - 1] * p;
    }
}
 
ull get(int l, int r)
{
    return h1[r] - h1[l - 1] * p1[r - l + 1];
}
 
ull gett(int l, int r)
{
    return h2[r] - h2[l - 1] * p2[r - l + 1];
}
 
void solve()
{
    cin >> s;
 
    n = s.size();
 
    t = s;
 
    reverse(alls(t));
 
    t = " " + t, s = " " + s;
 
    ini(), inii();
 
    if (get(1, n) != gett(1, n))
    {
        YES;
 
        puts("1");
 
        for (int i = 1; i <= n; i++)cout << s[i];
 
        puts("");
 
        return;
    }
 
    int l1, l2, r1, r2;
 
    for (int i = 2; i < n - 1; i++)
    {
        l1 = 1, r1 = i;
        l2 = i + 1, r2 = n;
 
        if (get(l1, r1) != gett(n + 1 - r1, n + 1 - l1) && get(l2, r2) != gett(n + 1 - r2, n + 1 - l2))
        {
            YES;
 
            puts("2");
 
            for (int j = l1; j <= r1; j++)cout << s[j];
 
            cout << ' ';
 
            for (int j = l2; j <= r2; j++)cout << s[j];
 
            puts("");
 
            return;
        }
    }
 
    NO;
}
 
int main()
{
    int t;
 
    cin >> t;
 
    //t = 1;
 
    while (t--)solve();
 
    return 0;
}
```



## 马拉车算法：

用于处理出给定范围内所有回文串长度



字符串中心就是蘑菇中心，

蘑菇伞盖前一半的最长回文长度确定了就能确定后一半最长回文串长度，

每次发现更大范围的蘑菇就更新范围长度和蘑菇中心



奇数扩展以当前字符为中心向两边扩展，偶数字符以`$`为中心向两边扩展



特判整个字符串为回文串需要另外特判



[马拉车算法 | Coding Club](https://www.bilibili.com/video/BV1Sx4y1k7jG/?spm_id_from=333.999.0.0&vd_source=66a8eebd2abf3c387510e513856312af)



```cpp
void solve()
{
    cin>>n>>s;

    ss="#$";

    for(int i=0;i<n;i++)
    {
        ss+=s[i]; ss[i]+='$';
    }

    ss[i]+='.';  //  aaaaa -> 5

    maxx=0,id=0;

    for(int i=1;i<ss.size();i++)
    {
        if(maxx>2*id-i)len[i]=min(len[2*id-i],maxx-i);  // 对称位置被计算过
        else len[i]=1;

        while(ss[i-len[i]-1]==ss[i+len[i]+1])len[i]++;  // 以当前字符为中心向两边扩展

        if(i+len[i]>maxx)  // 有更长覆盖范围的蘑菇
        {
            maxx=i+len[i]; id=i;
        }
    }

    for(int i=2;i<ss.size()-2;i++)cout<<len[i]<<' ';  // 以各个点为中心扩展的长度
}
```





[Problem - 1944D - Codeforces](https://codeforces.com/problemset/problem/1944/D)



只要存在长度为k的字符串不是回文串就+k，

给出一个字符串s，给出q个询问，问区间`[l,r]`k值之和为多少



分析：



一般情况下，这个字符串为回文串：

`babcbab`，从`c`开始扩展，`ans = 2+3+4+...+(len-1) = (len+1)*(len-2)/2`



一般情况下，这个字符串不是回文串：

`abcdef`，`ans = 2+3+4+...+len = (len+2)*(len-1)/2`



特例：

`abababab`，任意选取奇数个字符都是回文串，偶数个都不是，`ans = 2+4+...+(len-len%2) = (1+len/2)*(len/2)`



`aaaaaaa`，选取任意长度的字符串都是回文串，`ans = 0`


