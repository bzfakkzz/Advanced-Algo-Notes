## bitset：



[C++ std::bitset - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/607895839)



二进制位容器

```cpp
bitset<32>st(n);  // 0~31位分别对应n的二进制位
bitset<N>st;      // 长度为N的bool数组

st.reset();       // 全部置0

st.set(i,st[i]||st[i-tem]);   // 将第i位设置为st[i]||st[i-tem]
```



[Problem - D - Codeforces](https://codeforces.com/contest/1966/problem/D)



要求构造一个数组<=25个数字，

任选数字能构成1~n，且不能构成k



分析：



1. 凑`[1, k-1]`

2. 凑`[k+1, n]`



求到`k`最高位`i`，$1+\cdots +2^{i-1}=2^i-1$，此时能凑到的范围是$1\sim 2^i-1$，

再加上$k-2^i$，此时新增范围为$1+k-2^i\sim k-1$，

两个区间数字个数加起来为$2\cdot(2^i-1)=2^{i+1}-2$，

$(1+\cdots + 2^i)-1=(2^{i+1}-1)-1$，刚好为$1\sim 2^{i+1}$中除去$2^i$和$k$



用bitset记录当前能被得到的数字，

遍历k+1~n，将没有被凑出的数字放入答案并借此更新别的数字



```cpp
void solve()
{
    st.reset();

    st[0]=true;

    tem=1;

    cin>>n>>k;

    while(2*tem-1<k)
    {
        ans.push_back(tem);

        for(int i=n;i>=tem;i--)
        {
            st.set(i,st[i]||st[i-tem]);
        }

        tem<<=1;
    }

    if(k-tem>0)
    {
        ans.push_back(k-tem);

        for(int i=n;i>=k-tem;i--)
        {
            st.set(i,st[i]||st[i-(k-tem)]);
        }
    }

    for(int i=k+1;i<=n;i++)
    {
        if(!st[i])
        {
            ans.push_back(i);

            for(int j=n;j>=i;i--)
            {
                st.set(j,st[j]||st[j-i]);
            }
        }
    }

    cout<<ans.size()<<endl;

    for(auto u:ans)cout<<u<<' ';  puts("");
}
```



```cpp
#include <bits/stdc++.h>
#include <functional>
 
#define alls(a) a.begin(),a.end()
#define emb emplace_back
#define pub push_back
#define pob pop_back
#define puf push_front
#define pof pop_front
#define fi first
#define se second
#define No puts("No")
#define Yes puts("Yes")
#define NO puts("NO")
#define YES puts("YES")
 
using namespace std;
typedef long long ll;
//typedef __int128 lll; // G++(32位)不支持
typedef unsigned long long ull;
typedef pair<int, int> pii;
 
const int N = 1e6 + 10;
const int mo = 1e9 + 7;
const int inf = 2e9 + 10;
 
int n, k;
ll tem;
bitset<N>st;
 
void solve()
{
	cin >> n >> k;
 
	st.reset();
 
	st[0] = true;
 
	tem = 1;
 
	vector<ll>ans;
 
	// [ 1 , (2^i)-1 ]
 
	while (2 * tem - 1 < k)  // (2^i) - 1 = 1 + ... + (2^(i-1))
	{
		ans.emb(tem);
 
		for (int i = n; i >= tem; i--)
		{
			st.set(i, st[i] || st[i - tem]);
		}
 
		tem <<= 1;
	}
 
	// k - tem = k - (2^i)
	// [ k-(2^i)+1 , k-1 ]
 
	// (2^(i+1)) - 2 = ( 1 + ... + (2^i) ) - 1
 
	if ((k - tem) > 0)
	{
		ans.emb(k - tem);
 
		for (int i = n; i >= k - tem; i--)
		{
			st.set(i, st[i] || st[i - (k - tem)]);
		}
	}
 
	for (int i = k + 1; i <= n; i++)
	{
		if (!st[i])
		{
			ans.emb(i);
 
			for (int j = n; j >= i; j--)
			{
				st.set(j, st[j] || st[j - i]);
			}
		}
	}
 
	cout << ans.size() << endl;
 
	for (auto u : ans)cout << u << ' ';
 
	puts("");
}
 
int main()
{
	int t;
 
	cin >> t;
 
	//t = 1;
 
	while (t--)solve();
 
	return 0;
}
```
