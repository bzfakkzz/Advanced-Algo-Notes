[1378. 谦虚数字 - AcWing题库](https://www.acwing.com/problem/content/1380/)



求第n小的谦虚数字（1不是谦虚数字）



分析：



f数组记录当前第i小的合法数字，单调上升



`b[i]`用于记录当前和`p[i]`相乘能`>f[i-1]`的`f[j]`下标，

相当于通过已经计算出的小结果推更大的结果



```cpp
void solve()
{
    cin>>k>>n;

    for(int i=1;i<=k;i++)
    {
        cin>>p[i];
    }

    f[0]=1;

    for(int i=1;i<=n;i++)
    {
        cur=inf;

        for(int j=1;j<=k;j++)
        {
            while(p[j]*f[b[j]]<=f[i-1])b[j]++;

            cur=min(cur,p[j]*f[b[j]]);
        }

        f[i]=cur;
    }

    cout<<f[n]<<endl;
}
```



```cpp
#include <bits/stdc++.h>
#include <functional>

#define alls(a) a.begin(),a.end()
#define emb emplace_back
#define pub push_back
#define pob pop_back
#define puf push_front
#define pof pop_front
#define fi first
#define se second
#define No puts("No")
#define Yes puts("Yes")
#define NO puts("NO")
#define YES puts("YES")

using namespace std;
typedef long long ll;
//typedef __int128 lll; // G++(32位)不支持
typedef unsigned long long ull;
typedef pair<int, int> pii;

const int N = 1e5 + 10;
const int mo = 1e9 + 7;
const ll inf = 2e18 + 10;

int n, k;
ll minn;
ll a[N], b[N], f[N];

void solve()
{
	cin >> k >> n;

	for (int i = 1; i <= k; i++)cin >> a[i];

	f[0] = 1;

	for (int i = 1; i <= n; i++)
	{
		minn = inf;

		for (int j = 1; j <= k; j++)
		{
			while (a[j] * f[b[j]] <= f[i - 1])b[j]++;  // 选择最小的一个满足要求的数乘上当前因子，下次查找直接从这个数开始

			minn = min(minn, a[j] * f[b[j]]);
		}

		f[i] = minn;
	}

	cout << f[n] << endl;
}

int main()
{
	int t;

	//cin >> t;

	t = 1;

	while (t--)solve();

	return 0;
}
```
