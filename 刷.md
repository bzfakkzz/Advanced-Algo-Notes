### **递推**





[P1255 数楼梯 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1255)



爬楼梯，每次能爬1级或者2级，求一共有多少种爬法



分析：



每次要么是从i-1级爬来的，要么是从i-2级爬来的

因此**f[i]=f[i-1]+f[i-2]**，等于这俩数目之和

f[1]=1，f[2]=2



结合题目的范围可知，本题需要用到高精度





```cpp
#include <bits/stdc++.h>
#include <iostream>

using namespace std;

vector<int> add(vector<int>& a, vector<int>& b)
{
    vector<int>c;

    int t = 0;

    int len = min(a.size(), b.size());

    for (int i = 0; i < len; i++)
    {
        int now = a[i] + b[i] + t;

        c.push_back(now % 10);

        t = now / 10;
    }

    if (len < b.size())
    {
        for (int i = len; i < b.size(); i++)
        {
            int now = b[i] + t;

            c.push_back(now % 10);

            t = now / 10;
        }
    }
    else if (len < a.size())
    {
        for (int i = len; i < a.size(); i++)
        {
            int now = a[i] + t;

            c.push_back(now % 10);

            t = now / 10;
        }
    }

    if (t)c.push_back(t);

    return c;
}

int main()
{
    int n;

    cin >> n;

    vector<int>a;
    vector<int>b;

    a.push_back(1);
    b.push_back(2);

    if (n == 1)
    {
        puts("1");

        return 0;
    }
    else if (n == 2)
    {
        puts("2");

        return 0;
    }

    for (int i = 3; i <= n; i++)
    {
        vector<int>x = b;
        b = add(a, b);
        a = x;
    }

    for (int i = b.size() - 1; i >= 0; i--)
        cout << b[i];

    return 0;
}
```





### **递归**





[143. 重排链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reorder-list/description/)



将node[n+1-i]接到node[i]后面



由于我们是将它接到它后面，最后一个结点的后一个结点此时更新为链表尾



因此设置2个指针，pre，cur，分别代表倒数第二个结点和最后一个结点

每次找到都：

cur->next=head->next

head->next=cur

pre->next=nullptr



下一次对子链表进行递归处理，略过已经处理的这两个结点

return reorderList(head->next->next)





```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:

    void reorderList(ListNode* head) {
        if(head==nullptr||head->next==nullptr||head->next->next==nullptr)return;

        auto pre=head;
        auto cur=head->next;

        while(cur->next)
        {
            pre=cur;
            cur=pre->next;
        }

        cur->next=head->next;
        head->next=cur;
        pre->next=nullptr;

        return reorderList(head->next->next);
    }
};
```





[24. 两两交换链表中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)



两两交换链表结点



拿最前面两个结点

注意到newhead=head->next



每次返回的都是下一个子链表的head，下一个子链表的头结点为head->next->next



于是，得到式子：

head->next=swapPairs(head->next->next)



newhead->next=head



最后return newhead





```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(head==nullptr||head->next==nullptr)return head;

        ListNode* newhead=head->next;

        head->next=swapPairs(head->next->next);

        newhead->next=head;

        return newhead;
    }
};
```





[779. 第K个语法符号 - 力扣（LeetCode）](https://leetcode.cn/problems/k-th-symbol-in-grammar/description/)



观察发现，每行前半段和上一行是相同的

每行后半段，恰好是前半段对应位置字符求反



已知1^1=0，1^0=1，因此要对0，1取反只要令其^1



我们得到第n行一共有1<<(n-1)个数字，前半部分数字个数为1<<(n-2)



于是每次求出mid=1<<(n-2)

如果k>=mid，证明在前半段，则`return kthGrammar(n-1,k)`

否则`return 1^kthGrammar(n-1,k-mid)`





```cpp
class Solution {
public:
    int kthGrammar(int n, int k) {
        if(n==1)return 0;

        int mid=(1<<(n-2));

        if(k<=mid)return kthGrammar(n-1,k);

        return 1^kthGrammar(n-1,k-mid);
    }
};
```





[390. 消除游戏 - 力扣（LeetCode）](https://leetcode.cn/problems/elimination-game/solutions/1185419/xiao-chu-you-xi-by-leetcode-solution-ydpb/)



假设从左到右删除元素：

1. 个数为奇数

2. 个数为偶数
   
   

假设从右到左删除元素：

1. 个数为奇数

2. 个数为偶数
   
   

规定前一种的等差差值为step

step=1



1 2 3 4 5 6 7 8 9

1 2 3 4 5 6 7 8 9 10 11 12



第一种：

2 4 6 8 

a1'=a1+step，an'=an-step

2 4 6 8 10 12

a1'=a1+step，an'=an



第二种：

2 4 6 8

a1'=a1+step，an'=an-step

1 3 5 7 9 11

a1'=a1，an'=an-step



此时我们变换过后step变为2

an=a1+(cnt-1)*step



step每次都*2

cnt每次/2





```cpp
class Solution {
public:
    int lastRemaining(int n) {
        int a1=1;

        int k=1;
        int cnt=n;
        int step=1;

        while(cnt>1)
        {
            if(k%2)
            {
                a1=a1+step;
            }
            else 
            {
                if(cnt%2)a1=a1+step;
            }

            k++;
            cnt>>=1;
            step<<=1;
        }

        return a1;
    }
};
```





递归求快速幂：



例：

[50. Pow(x, n) - 力扣（LeetCode）](https://leetcode.cn/problems/powx-n/)



<<1相当于^2（平方）





```cpp
class Solution {
public:

    double qmi(double a,long long b)
    {
        if(b==0)return 1;

        double c=qmi(a,b/2);

        if(b&1)return c*c*a;
        else return c*c; 
    }

    double myPow(double x, int n) {

        long long b=n;

        if(n>=0)return qmi(x,b);
        else return 1.0/qmi(x,-b);

    }
};
```





```cpp
class Solution {
public:
    double qmi(double a,long long b)
    {
        if(b==0)return 1;

        double c=qmi(a,b>>1);   //  右移一位

        return b&1?c*c*a:c*c;   //  左移回来，如果当前有被选择那就乘上
    }

    double myPow(double x, int n) {
            long long b=n;      //  防止负数

            if(b>=0)return qmi(x,b);
            else return 1.0/qmi(x,-b);
    }
};
```





[2. 两数相加 - 力扣（LeetCode）](https://leetcode.cn/problems/add-two-numbers/description/)



分析：



从头到尾，依次取值进位



一个头指针，一个尾指针（方便进位）



注意每次取值有个巧妙的方法：

`n1=l1?l1.val:0`

观看这个链表是否到达末尾，如果到达就直接取为0



保存高位的方法：

`ed->next=new ListNode(sum%10)`

`ed=ed->next`



```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {

       ListNode*st=nullptr;
       ListNode*ed=nullptr;

       int t=0;

       while(l1||l2) 
       {
           int n1=l1?l1->val:0;
           int n2=l2?l2->val:0;

           int sum=n1+n2+t;

           if(!st)
           {
               st=ed=new ListNode(sum%10);
           }
           else
           {
               ed->next=new ListNode(sum%10);
               ed=ed->next;
           }

           t=sum/10;

           if(l1)
           {
               l1=l1->next;
           }

           if(l2)
           {
               l2=l2->next;
           }
       } 

       if(t>0)
       {
           ed->next=new ListNode(t);
       }

       return st;

    }
};
```





### **枚举**





[Problem - B - Codeforces](https://codeforces.com/contest/1882/problem/B)





记录每个值所属的集合 row

记录每个集合有几个数字

记录每个数字出现几次

为了方便取值，开一个二维数组记录每个值



枚举每个值val，将所有包含它的集合删完



每次判断是否有更优解





```cpp
#include <bits/stdc++.h>
#include <iostream>

using namespace std;

void solve()
{
    int n;

    cin >> n;

    int sum = 0;

    vector<vector<int>>row(55, vector<int>());
    vector<vector<int>>b(55, vector<int>(55, 0));
    vector<int>assign(n + 1, 0);
    map<int, int>mp;

    int num;

    for (int i = 1; i <= n; i++)
    {
        cin >> assign[i];

        for (int j = 0; j < assign[i]; j++)
        {
            cin >> b[i][j];

            row[b[i][j]].push_back(i);  // row

            if (++mp[b[i][j]] == 1)sum++;
        }
    }

    int ans = 0;

    for (int val = 1; val <= 50; val++)
    {
        if (row[val].empty())continue;

        int cur = sum;

        for (auto i : row[val])
        {
            for (int j = 0; j < assign[i]; j++)
            {
                if (--mp[b[i][j]] == 0)cur--;
            }
        }

        ans = max(ans, cur);

        for (auto i : row[val])
        {
            for (int j = 0; j < assign[i]; j++)
            {
                ++mp[b[i][j]];
            }
        }
    }

    cout << ans << endl;
}

int main()
{
    int t;

    cin >> t;

    while (t--)
        solve();

    return 0;
}
```





[1291. 顺次数 - 力扣（LeetCode）](https://leetcode.cn/problems/sequential-digits/description/)



分析：



因为每一位都比前面一位大1



先枚举第一个位置1~9，固定最高位

之后顺次枚举后面的位置



如果符合要求就加入ans





```cpp
class Solution {
public:
    vector<int> sequentialDigits(int low, int high) {

        vector<int>ans;

        for(int i=1;i<=9;i++)
        {
            int num=i;

            for(int j=i+1;j<=9;j++)
            {
                num*=10;

                num+=j;

                if(num>=low&&num<=high)
                {
                    ans.push_back(num);
                }
            }
        }

        sort(ans.begin(),ans.end());

        return ans;

    }
};
```





和前缀和结合：



[1292. 元素和小于等于阈值的正方形的最大边长 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/description/)



分析：



求解一块方形区域前缀和（包含(x1,y1)）

设左上角顶点(x1,y1)，右上角顶点(x2,y2)

则前缀和为s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1]



之后三重循环，枚举行，枚举列，枚举边长进行求解最大边长



优化——

由于我们要找的是最大边长，因此我们每次枚举边长的时候从ans+1开始枚举，到min(n,m)结束





```cpp
class Solution {
public:

    int S(const vector<vector<int>>&s,int x1,int y1,int x2,int y2)
    {
        return s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1];  //  找到这一块方形区域的面积
    }

    int maxSideLength(vector<vector<int>>& mat, int threshold) 
    {
        int m=mat.size();
        int n=mat[0].size();

        vector<vector<int>>s(m+1,vector<int>(n+1,0));

        for(int i=1;i<=m;i++)
        {
            for(int j=1;j<=n;j++)
            {
                s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+mat[i-1][j-1];  //  预处理前缀和
            }
        }        

        int x=min(m,n),ans=0;    //  最多能达到的边长

        for(int i=1;i<=m;i++)    //  枚举行
        {
            for(int j=1;j<=n;j++)   //  枚举列
            {
                for(int k=ans+1;k<=x;k++)   //  枚举边长
                {
                    if(i+k-1<=m && j+k-1<=n && S(s,i,j,i+k-1,j+k-1)<=threshold)
                    {
                        ans++;
                    }
                    else break;
                }
            }
        }

        return ans;
    }
};
```



线性筛质数：



[204. 计数质数 - 力扣（LeetCode）](https://leetcode.cn/problems/count-primes/description/)



```cpp
class Solution {
public:
    int countPrimes(int n) {

        vector<int>pri(n+1,0);

        int cnt=0;

        vector<bool>st(n+1,false);

        st[0]=st[1]=true;

        for(int i=2;i<=n;i++)
        {
            if(!st[i])
            {
                pri[cnt++]=i;
            }

            for(int j=0;pri[j]<=n/i;j++)
            {
                st[pri[j]*i]=true;

                if(i%pri[j]==0)break;
            }
        }

        if(st[n]==false)cnt--;

        return cnt;
    }
};
```





### **深度优先遍历DFS**





求最大连通块的权值之和：



例：

[Problem - 1829E - Codeforces](https://codeforces.com/problemset/problem/1829/E)





```cpp
#include <bits/stdc++.h>
#include <iostream>

using namespace std;

vector<int>ans;
vector<vector<int>>a;
vector<vector<bool>>st;
int n, m;
int cnt;

const int dx[4] = { 0,0,-1,1 };
const int dy[4] = { 1,-1,0,0 };

void dfs(int x, int y,int cnt)
{
    if (st[x][y] || a[x][y] == 0 || x < 1 || x > n || y < 1 || y > m)
    {
        return;
    }

    st[x][y] = true;

    ans[cnt] += a[x][y];

    for (int i = 0; i < 4; i++)
    {
        int x1 = x + dx[i];
        int y1 = y + dy[i];

        if (x1<1 || x1>n || y1<1 || y1>m)continue;  //  这里由于是搜索最大连通块，因此在这里不进行判断是否有被遍历过而是在开头

        dfs(x1, y1, cnt);
    }

    return;
}

void solve()
{
    cin >> n >> m;

    a = vector<vector<int>>(n + 1, vector<int>(m + 1, 0));
    st = vector<vector<bool>>(n + 1, vector<bool>(m + 1, false));

    cnt = -1;

    ans = vector<int>((n + 1) * (m + 1), 0);

    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
            cin >> a[i][j];
    }

    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            if (a[i][j] && !st[i][j])
            {
                cnt++;
                dfs(i, j, cnt);
            }
        }
    }

    int maxx = 0;

    for (int i = 0; i <= cnt; i++)
    {
        maxx = max(maxx, ans[i]);
    }

    cout << maxx << endl;
}

int main()
{
    int t;

    cin >> t;

    while (t--)
        solve();

    return 0;
}
```





### **DP**





[Problem - D - Codeforces](https://codeforces.com/contest/1875/problem/D)



给定一组包含n个数字的序列a

每次能进行如下操作：

1. 选定一个数字ai，进行删除

2. m+=mex(a)

直到n个数字被全部删完，求最小的m结果是什么



分析：



统计每个数字出现的次数，方便枚举删除所有数字需要花费的代价



f[i]表示mex值为i的情况下m的最小值



我们首先找到所有数字的起始mex值

1. 它是0，m[min]=0

2. 非0
   
   

对于第2种情况，我们f[mex]=0

由于mex值只可能越来越小，因此我们第一重循环从mex-1开始枚举一直到0

第二重循环枚举所有可能走到i的情况，从mex到i+1



状态转移方程就是：

`f[i]=min(f[i],f[j]+j*(mp[i]-1)+i)`



最后mex值为0一定是最小答案，因此我们输出f[0]





```cpp
#include <bits/stdc++.h>
#include <iostream>

using namespace std;
typedef long long ll;

void solve()
{
    int n;

    cin >> n;

    vector<ll>f(n + 1, 0ll);  // 0ll
    map<int, int>mp;

    int maxx = 0;
    int x;

    for (int i = 0; i < n; i++)
    {
        cin >> x;

        mp[x]++;

        maxx = max(maxx, x);
    }

    int mex = 0;

    while (mp.find(mex) != mp.end())
    {
        mex++;
    }

    if (mex == 0)
    {
        puts("0");
    }
    else
    {
        ll ans = 1ll * (maxx + 1) * n;

        for (int i = mex - 1; i >= 0; i--)
        {
            f[i] = 1ll * (maxx + 1) * n;

            for (int j = i + 1; j <= mex; j++)
            {
                f[i] = min(f[i], f[j] + 1ll * (mp[i] - 1) * j + i);
            }
        }

        cout << f[0] << endl;
    }
}

int main()
{
    int t;

    cin >> t;

    while (t--)
        solve();

    return 0;
}
```





### **贪心**





[Problem - A - Codeforces](https://codeforces.com/contest/1770/problem/A)





分析：



每次能将黑板上的n个数中挑选一个变成m个数中的一个

注意有可能一个位置被多次转换

因此我们选择一个小根堆来实现





```cpp
#include <bits/stdc++.h>
#include <iostream>

using namespace std;
typedef long long ll;

void solve()
{
    int n, m;

    cin >> n >> m;

    priority_queue<int, vector<int>, greater<int>>heap;

    vector<int>a(n);
    vector<int>b(m);

    for (int i = 0; i < n; i++)
    {
        cin >> a[i];
        heap.push(a[i]);
    }

    for (int i = 0; i < m; i++)
    {
        cin >> b[i];
    }

    ll sum = 0;

    for (int i = 0; i < m; i++)
    {
        heap.pop();

        heap.push(b[i]);
    }

    while (!heap.empty())
    {
        sum += heap.top();
        heap.pop();
    }

    cout << sum << endl;
}

int main()
{
    int t;

    cin >> t;

    while (t--)
        solve();

    return 0;
}
```





[Problem - B - Codeforces](https://codeforces.com/contest/1725/problem/B)





可以把一堆数字全部变成他们中的最大值

要求一共最多能分出多少堆，每堆的值需要>目标值



分析：



sort一遍

从后往前计算需要多少个数字才能满足要求

由于值越大需要的数字个数就越小，因此一定是正确的



每次至少需要k=d/a[j]+1个数，包含了我们从后往前的数字，因此我们i的下标从-1开始，一共加k-1个数字

i+=k-1，可以推算出下一个下标是多少



为什么从-1开始：



假设从0开始

假设一共需要加上k=3个数字，那么末尾数字的下标是3

我们数字下标从0开始，因此此时对应的是第4个数字，不合题意



假设从-1开始

加上3之后，下标变为2，此时对应的是第3个数字，符合题意





```cpp
#include <bits/stdc++.h>
#include <iostream>

using namespace std;

void solve()
{
    int n, d;

    cin >> n >> d;

    vector<int>a(n, 0);

    for (int i = 0; i < n; i++)
        cin >> a[i];

    sort(a.begin(), a.end());

    int ans = 0;

    for (int i = -1, j = n-1; i < j; j--)
    {
        int k = d / a[j] + 1;

        if (i + k - 1 < j)ans++;

        i += k - 1;
    }

    cout << ans << endl;
}

int main()
{
    solve();

    return 0;
}
```





[Problem - C - Codeforces](https://codeforces.com/contest/1882/problem/C)



考虑第一个非负数的位置idx：

1. 如果idx是奇数，则一定能全部加上正数

2. 如果idx为大于等于3的偶数，则可以通过删除前面在第2位的负数，达到全部正数相加的目的

3. 当idx为2，则考虑是否加上前面的负数，或者不加当前位的数字，后面的正数全部相加
   
   

证明1：



从后往前考虑最上面的非负数：

1. 是偶数位

2. 是奇数位
   
   

第一种情况，找到该位后面的第一个奇数位的非负数，进行删除相加操作，此时当前位的正数可以变为奇数位被加

由于最后一个是奇数位，因此总能找到这样一个位置



第二种情况，一定能被删除相加，由于是从后向前考虑，因此一定不会影响到后面位置的奇偶性



证明3：



当前位的数字可以选择删/不删，因此倒数第二个非负数的奇偶性一定可以被我们控制

于是我们一定可以把下一个非负数的位置变成奇数，所有的非负数都能取到





```cpp
#include <bits/stdc++.h>
#include <iostream>

using namespace std;

void solve()
{
    int n;

    cin >> n;

    vector<int>a(n + 1, 0);

    int idx = 0;

    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        if (idx == 0 && a[i] >= 0)idx = i;
    }

    long long ans = 0;

    if (idx > n)ans = 0;
    else if (idx % 2 || idx >= 3)
    {
        for (int i = idx; i <= n; i++)
        {
            if (a[i] > 0)ans += a[i];
        }
    }
    else
    {
        int cur = a[idx] + a[1];

        if (cur < 0)
        {
            for (int i = idx + 1; i <= n; i++)
            {
                if (a[i] > 0)ans += a[i];
            }
        }
        else
        {
            ans += cur;
            for (int i = idx + 1; i <= n; i++)
            {
                if (a[i] > 0)ans += a[i];
            }
        }
    }

    cout << ans << endl;
}

int main()
{
    int t;

    cin >> t;

    while (t--)
        solve();

    return 0;
}
```





### **数学&规律**





[Problem - C - Codeforces](https://codeforces.com/contest/1789/problem/C)



给出n个数字，给出m个操作

每次操作将给定下标的数字变为给定数字，保证两两不同

试问每次操作后得到的集合两两元素取交集，一共是$\ \frac {m\cdot(m+1)} 2\ $组

得到所有元素的总和为多少



分析：



求A[j]的一个元素中a[i]的对结果的贡献：



统计当前元素在之前出现了几次，每次的权重为-1

因为每出现一次就意味着当前这个a[i]对于它们没有贡献



每次先加上当前这组的全部元素，个数为n

统计方法采用，当前位置减去该值对应的之前位置，即`i-last[a[l]]`

同时当前值既然替换成了r，那就意味着之前一直没有r，`cnt+=sum[r]`



假设所有数组值都不同，则一共有2 * n * i种（取任意2数组，一共2n个数字随便取，在所有i次替换中选择了其中一次）





```cpp
#include <bits/stdc++.h>
#include <iostream>

using namespace std;
typedef long long ll;

void solve()
{
    ll n, m;

    cin >> n >> m;

    vector<int>last(n + m + 1, 0); // 记录上一次出现的位置
    vector<ll>sum(n + m + 1, 0);  // 当前数字累计出现的次数

    vector<int>a(n + 1, 0);

    for (ll i = 1; i <= n; i++)
    {
        cin >> a[i];
    }

    ll ans = 0;
    ll cnt = 0;  // 记录这一轮所有数在本轮之前重复出现的次数

    for (ll i = 1; i <= m; i++)
    {
        int l, r;

        cin >> l >> r;

        sum[a[l]] += i - last[a[l]];  // 该数被修改，用当前位置减去上次出现的位置求出重复次数

        last[r] = i;

        cnt += n;          // 加上这一组的所有数字
        cnt -= sum[a[l]];  // 减去多减的被重复替换的个数
        cnt += sum[r];     // 由于r一定没出现过，因此我们加上r出现的所有次数

        ans += 2 * n * i - cnt;

        a[l] = r;
    }

    cout << ans << endl;
}

int main()
{
    int t;

    cin >> t;

    while (t--)
        solve();

    return 0;
}
```





[Problem - C - Codeforces](https://codeforces.com/contest/1802/problem/C)





分析：



首先，构造的矩阵中最多不同的数有n*m个



我们发现只要让每一个2*2大小的子矩阵四个数异或值等于0即满足题意

一堆数的异或值等于0，当且仅当每一个二进制位0和1的个数都是偶数



只要构造的第一行数确定了，其他所有行的所有数也确定了

令第一个数为0，第一行的数可以是0，1，...，m-1

由于2^8=256，而范围为<=200

第二行的数字用第一行的数字加上1<<8就不会和第一行有任何冲突，并且满足题意



以此类推，每一行都是这样

......





```cpp
#include <bits/stdc++.h>
#include <iostream>

using namespace std;

typedef long long ll;

void solve()
{
    int n, m;

    cin >> n >> m;

    cout << n * m << endl;

    for (ll i = 0; i < n; i++)
    {
        for (ll j = 0; j < m; j++)
            cout << (i << 8) + j << ' ';

        puts("");
    }
}

int main()
{
    int t;

    cin >> t;

    while (t--)
        solve();

    return 0;
}
```





[Problem - B - Codeforces](https://codeforces.com/contest/1794/problem/B)



给定一串数据，每次都能将其中一个++

保证进行不多于2n次操作之后使得每个a[i+1]不能被a[i]整除



分析：



当包含的数字中没有1的时候，如果a[i]%a[i-1]==0则一定有(a[i]+1)%a[i-1]!=0，此时我们每次++即可

当遇到1的时候，我们只需要把它变成不是1的数字即2即可





```cpp
#include <bits/stdc++.h>
#include <iostream>

using namespace std;

void solve()
{
    int n;

    cin >> n;

    vector<int>a(n);

    for (int i = 0; i < n; i++)
        cin >> a[i];

    if (a[0] == 1)a[0]++;

    for (int i = 1; i < n; i++)
    {
        if (a[i] == 1)a[i]++;

        while (a[i] % a[i - 1] == 0)a[i]++;
    }

    for (int i = 0; i < n; i++)
        cout << a[i] << ' ';

    puts("");
}

int main()
{
    int t;

    cin >> t;

    while (t--)
        solve();

    return 0;
}
```





[Problem - B - Codeforces](https://codeforces.com/contest/1802/problem/B)



给定一串数字

当为1的时候就是放入一个猪崽

当为2的时候有医生来区分性别

我们将同一个性别的放入一个猪笼，将不同性别的放进不同猪笼

问一共要最小花费多少猪笼



分析：



根据鸽巢原理，考虑只有四只性别不明的猪崽

其中至少有两个能性别不同，此时至少有一对能性别相同配对，最多只能留下两个落单的

1 1 1 1  （2）

1 1 1 0  （3）

1 1 0 0

1 0 0 0

0 0 0 0

最坏情况下会有 1 1 1 0

我们需要3只笼子

1 0 1 0 1 0 ... 1 1 1 0

n为偶数的情况下，需要笼子个数为(n-2)/2+2

假设多出来的2只为 0 1，需要两个笼子安放



n为奇数的情况下，最坏情况是1 0 1 0 1 0 ... 1 0 1，需要笼子个数为n/2+1，前面相同的配对，后面一个单调成对



我们用sum1表示当前还有几只猪没配对呢

用sum2表示猪笼使用个数



当遇到2的时候就合计一下：

1. sum1为奇数

2. sum1为偶数
   
   

第一种情况下sum2+=sum1/2，sum1=1

第二种情况下sum2+=(sum1-1)/2，sum1=2





```cpp
#include <bits/stdc++.h>
#include <iostream>

using namespace std;
typedef long long ll;

void solve()
{
    int n;

    cin >> n;

    vector<int>a(n);

    for (int i = 0; i < n; i++)
        cin >> a[i];

    ll ans = 0;
    ll sum1 = 0, sum2 = 0;

    for (int i = 0; i < n; i++)
    {
        if (a[i] == 1)sum1++;
        else
        {
            if (sum1 == 0)continue;
            else if (sum1 & 1)
            {
                sum2 += sum1 / 2, sum1 = 1;  // 前面的都放猪笼了，这还剩几只没配对和下次一起合计
            }
            else
            {
                sum2 += (sum1 - 2) / 2, sum1 = 2;
            }
        }

        ans = max(ans, sum1 + sum2);
    }

    cout << ans << endl;
}

int main()
{
    int t;

    cin >> t;

    while (t--)
        solve();

    return 0;
}
```





[Problem - C - Codeforces](https://codeforces.com/contest/1875/problem/C)



给定n个苹果分给m个人

每次只能将苹果一切二

问至少多少刀



分析：



如果要正好分给m个人，一共至少有k=m*n/gcd(m,n)片

每个人拥有x=k/m片

每个苹果为y=k/n片

由于一个苹果每次都只能被分成两片，因此这里的y必须是2的幂次方



为了减少切的个数，我们将2片组一片，4片组一片...分给每个人

实际上就是x二进制位上1的位数

这样我们总共需要count(x)*m片



原本拥有n片，每切一刀增加一片

因此需要切count(x)*m-n片



**统计二进制为1的位数：**

1. __builtin_popcount(x)

2. 每次都删除一个二进制位的1
   
   

x&(x-1)能删除x二进制最低位上的1

如：

1001001 & 1001000 == 1001000

1001000 & 1000111 == 1000000

无论奇偶都可以删除完成



作为条件时，**x&(x-1)判断当前数字是否是2的幂次方**



如：

100001  100000 &=1

110000  101111 &=1

100000  011111 &=0



```cpp
// 统计所有二进制位上1的个数

while(x)
{
    x&=(x-1);
    cnt++;
}
```



x&(-x)能返回**最低位的1**





```cpp
#include <bits/stdc++.h>
#include <iostream>

using namespace std;
typedef long long ll;

ll gcd(ll a, ll b)
{
    return  b ? gcd(b, a % b) : a;
}

void solve()
{
    ll n, m;  //  苹果个数  人数

    cin >> n >> m;

    n %= m;

    if (n % m == 0)
    {
        puts("0");
    }
    else if (m % 2)
    {
        puts("-1");
    }
    else
    {
        ll k = n * m / gcd(n, m);

        ll x = k / m;
        ll y = k / n;

        if (y&(y-1))  //  不是2的幂次方
        {
            puts("-1");
        }
        else
        {
            ll cnt = 0;

            while (x)
            {
                cnt++;

                x &= (x - 1);
            }

            cout << cnt * m - n << endl;
        }
    }
}

int main()
{
    int t;

    cin >> t;

    while (t--)
        solve();

    return 0;
}
```





[Problem - 1760D - Codeforces](https://codeforces.com/problemset/problem/1760/D)





符合规律的话应该只有一个“谷”

上升则意味着已经有一个”谷“

如果上升之后再下降必然就是多于一个”谷“，该情况一定不符要求



`a[i]<a[i+1]`

`a[i]>a[i-1]`





```cpp
#include <bits/stdc++.h>
#include <iostream>

using namespace std;

void solve()
{
    int n;

    cin >> n;

    vector<int>a(n);

    for (int i = 0; i < n; i++)
        cin >> a[i];

    bool flag1 = false;
    bool flag2 = false;

    for (int i = 0; i < n-1; i++)
    {
        if (a[i] < a[i + 1])flag1 = true;  //  第一次的上升

        if (flag1 && a[i] > a[i + 1])      //  存在上升之后下降的情况
        {
            flag2 = true;
            break;
        }
    }

    if (flag2)puts("NO");
    else puts("YES");
}

int main()
{
    int t;

    cin >> t;

    while (t--)
        solve();

    return 0;
}
```





[Problem - 1770B - Codeforces](https://codeforces.com/problemset/problem/1770/B)



给定一个数字构造一个序列使得：

每个长度为k的窗口中最小值和最大值之和，的最大值，最小



分析：



不要被这个k迷惑



一定是n+1

由于每个窗口自左向右滑动，因此是单调的

此时我们发现构造这样的序列能达到要求：

n  1  n-1  2  n-2  3 ...





```cpp
#include <bits/stdc++.h>
#include <iostream>

using namespace std;

void solve()
{
    int n, k;

    cin >> n >> k;

    if (n == k || k == 1)
    {
        for (int i = 1; i <= n; i++)
            cout << i << " ";

        puts("");

        return;
    }

    vector<int>a;

    for (int i = n; i > n / 2; i--)
    {
        a.push_back(i);
        if (i != n - i + 1)a.push_back(n - i + 1);
    }

    for (auto x : a)
        cout << x << ' ';

    puts("");
}

int main()
{
    int t;

    cin >> t;

    while (t--)
        solve();

    return 0;
}
```





[Problem - 1863C - Codeforces](https://codeforces.com/problemset/problem/1863/C)



例：

原本有n=10个数字

5 3 0 4 2 1 6 9 10 8



下标从0开始

k==1  7 5 3 0 4 2 1 6 9 10 (8)    idx=n

k==2  8 7 5 3 0 4 2 1 6 9 (10)    idx=n-1

k==3  10 8 7 5 3 0 4 2 1 6 (9)    idx=n-2

k==4  9 10 8 7 5 3 0 4 2 1 (6)    idx=n-3

k==5  6 9 10 8 7 5 3 0 4 2 (1)    idx=n-4

......



得到规律，首先找到所有数字的mex值

构建一个原始序列，之后滚动排序，一个周期为n+1

第一个数字的下标为idx=(n+1-k)%(n+1)



`if(idx==n+1)idx=0`





```cpp
#include <bits/stdc++.h>
#include <iostream>

using namespace std;

void solve()
{
    int n, k;

    cin >> n >> k;

    set<int>st;
    vector<int>a(n + 1, 0);

    for (int i = 0; i < n; i++)
    {
        cin >> a[i];
        st.insert(a[i]);
    }

    for (int i = 0; i <= n; i++)
    {
        if (!st.count(i))
        {
            a[n] = i;
            break;
        }
    }

    k %= (n + 1);

    if (k == 0)k = n + 1;

    int idx = n + 1 - k;
    int cnt = n;

    while (cnt--)
    {
        cout << a[idx] << ' ';

        idx++;

        if (idx == n + 1)idx = 0;
    }

    puts("");
}

int main()
{
    int t;

    cin >> t;

    while (t--)
        solve();

    return 0;
}
```





[Problem - C - Codeforces](https://codeforces.com/contest/1861/problem/C)



给定一串字符s代表某人进行的所有操作

判断这些操作是否有可能发生

+：增加一个数字

-：减少一个数字

1：是升序

0：是降序



分析：



用num1表示前num1的数字是升序的（维护最长升序长度），数字为1的时候默认它是升序，初始化为1

用num2表示从第num2个数字开始降序（维护最小非升序长度）



+：

num1和num2都不变

-：

假设减完之后的数字个数为cur

cur>num1时，num1不变

cur<num2时，由于前面的数字都是升序的，因此没有属于它的降序序列，赋值为0x3f3f3f3f



判断1，0：

假如num2<=cur，则不可能是1（所有数字非升序）

否则，我们保存最大的升序序列个数

假如num1>=cur，则不可能是0（所有数字升序）

否则我们保存最少的降序序列个数





```cpp
#include <bits/stdc++.h>
#include <iostream>

using namespace std;

void solve()
{
    string s;

    cin >> s;

    int num1 = 1, num2 = 0x3f3f3f3f;
    int cur = 0;

    for (int i = 0; i < s.size(); i++)
    {
        if (s[i] == '+')cur++;
        else if (s[i] == '-')
        {
            cur--;

            if (cur > 0 && num1 > cur)num1 = cur;

            if (num2 > cur)num2 = 0x3f3f3f3f;
        }
        else if (s[i] == '1')
        {
            if (num2 <= cur)
            {
                puts("NO");
                return;
            }
            else num1 = max(num1, cur);
        }
        else
        {
            if (num1 >= cur)
            {
                puts("NO");
                return;
            }
            else num2 = min(num2, cur);
        }
    }

    puts("YES");
    return;
}

int main()
{
    int t;

    cin >> t;

    while (t--)
        solve();

    return 0;
}
```





### **字符串**





给定所有零碎的前缀和后缀，判断整个字符串是否是回文串：



例：

[Problem - A - Codeforces](https://codeforces.com/contest/1794/problem/A)



回文串的所有长度相同的前缀和后缀都是回文的

因此只需要对它们逐一进行判断即可





```cpp
#include <bits/stdc++.h>
#include <iostream>

using namespace std;

void solve()
{
    int n;

    cin >> n;

    vector<vector<string>>a(n + 1);
    string x;


    for (int i = 0; i < 2 * n - 2; i++)
    {
        cin >> x;

        a[x.size()].push_back(x);
    }

    bool f = true;

    for (int i = 0; i < n + 1; i++)
    {
        if (!a[i].empty())
        {
            string x1 = a[i][0];
            string x2 = a[i][1];

            for (int j = 0; j < a[i][0].size(); j++)
            {
                if (x1[j] != x2[i - j - 1])
                {
                    f = false;
                    break;
                }
            }
        }

        if (!f)break;
    }

    if (f)puts("YES");
    else puts("NO");
}

int main()
{
    int t;

    cin >> t;

    while (t--)
        solve();

    return 0;
}
```





find函数：

a.find(b)找到子串b就返回第一个字母位置下标，否则就返回-1



例：

[Problem - A - Codeforces](https://codeforces.com/contest/1860/problem/A)





```cpp
#include <bits/stdc++.h>
#include <iostream>

using namespace std;

void solve()
{
    string s;

    cin >> s;

    int n = s.size();

    string x1 = "", x2 = "";

    for (int i = 0; i < n; i++)
    {
        x1 += "(";
    }

    for (int i = 0; i < n; i++)
    {
        x1 += ")";
    }

    for (int i = 0; i < n; i++)
    {
        x2 += "()";
    }

    int idx1 = x1.find(s);
    int idx2 = x2.find(s);

    if (idx1 != -1 && idx2 != -1)
    {
        puts("NO");
    }
    else
    {
        puts("YES");

        if (idx1 == -1)cout << x1 << endl;
        else cout << x2 << endl;
    }
}

int main()
{
    int t;

    cin >> t;

    while (t--)
        solve();

    return 0;
}
```





[Problem - B - Codeforces](https://codeforces.com/contest/1861/problem/B)



给定两串以0开头以1结尾的字符串

每次能把相同数字之前的数都变为他们

求是否有可能通过若干次操作使得字符串a，b相同



分析：



由于一个是以0结尾，一个是以1结尾

通过若干次操作一定能变成形如0011111这样的串



于是我们可以进行这样的判断：

`a[i]==b[i]&&a[i-1]==b[i-1]&&a[i]=='1'&&a[i-1]=='0'`

则一定能变成相同的字符串





```cpp
#include <bits/stdc++.h>
#include <iostream>

using namespace std;

void solve()
{
    string a, b;

    cin >> a >> b;

    if (a == b)
    {
        puts("YES");
        return;
    }

    for (int i = 1; i < a.size(); i++)
    {
        if (a[i] == b[i] && a[i - 1] == b[i - 1] && a[i] == '1' && a[i - 1] == '0')
        {
            puts("YES");
            return;
        }
    }

    puts("NO");
}

int main()
{
    int t;

    cin >> t;

    while (t--)
        solve();

    return 0;
}
```





### **组合**





凑整：



例：

[Problem - B - Codeforces](https://codeforces.com/contest/1860/problem/B)



m,k,a1,ak

我们先处理出这两堆整分每堆能对应的硬币个数（总数最小）：

int x=m%k;  //  a1

int y=m/k;    //  ak



假如a1>=x

`a1-=x;  // 除去需要用的第一种硬币数目`

`y-=a1/k;  // 除去这些剩下的第一种硬币最多能替代多少第k种硬币`

`ans=max(0ll,y-ak);  // 取得结果值`



否则就是a1<x

`ans=max(0ll,y-ak)+x-a1;  // 变为总数最小的最小代价`





```cpp
#include <bits/stdc++.h>
#include <iostream>

using namespace std;
typedef long long ll;

void solve()
{
    ll m, k, a1, ak;

    cin >> m >> k >> a1 >> ak;

    ll x = m % k;
    ll y = m / k;

    if (a1 >= x)
    {
        a1 -= x;

        y -= a1 / k;

        cout << max(0ll, y - ak) << endl;
    }
    else
    {
        cout << max(0ll, y - ak) + x - a1 << endl;
    }
}

int main()
{
    int t;

    cin >> t;

    while (t--)
        solve();

    return 0;
}
```





### **博弈**





[Problem - C - Codeforces](https://codeforces.com/contest/1860/problem/C)



一个ai能往左边进行移动，移动到比它小的数字的位置

只要一个人没办法进行移动那这个人就赢了

a先手，b后手，给定一个序列，问有多少种方法让a赢





分析：



只要能走到稳赢值那么就一定能稳赢



从左到右遍历这个序列

当前的最小值，和稳赢值（走到这个位置一定没有办法走到下一步）



如果当前值<minn，则a走这里b一定不能移动，此时b赢

更新minn，f=false



否则如果当前值>minlose，则a走到这里b一定能走到稳赢值去，此时b赢

f=false



每次更新cnt时都更新一下`minlose=min(minlose,p[i])`





```cpp
  #include <bits/stdc++.h>
#include <iostream>

using namespace std;

void solve()
{
    int n;
    cin >> n;

    vector<int>p(n, 0);

    for (int i = 0; i < n; i++)
        cin >> p[i];

    int cnt = 0;
    int minn = n + 1;
    int minlose = n + 1;

    for (int i = 0; i < n; i++)
    {
        bool f = true;

        if (p[i] < minn)     //  小于当前最小值必输（a选择这个值，b无法移动）
        {
            f = false;
            minn = min(p[i], minn);
        }
        else if (p[i] > minlose)  //  大于当前稳赢的值必输（a选这个值，b一定不动）
        {
            f = false;
        }

        if (f)
        {
            cnt++;
            minlose = min(minlose, p[i]);  //  更新当前稳赢值
        }
    }

    cout << cnt << endl;
}

int main()
{
    int t;

    cin >> t;

    while (t--)
        solve();

    return 0;
}
```
