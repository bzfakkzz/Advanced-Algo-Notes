[F - Double Sum (atcoder.jp)](https://atcoder.jp/contests/abc351/tasks/abc351_f)



求所有数字减去前面比它小的数字之和



分析：



树状数组支持动态查找修改，

先对结构体按照`x`进行排序，找到当前`a[i]`排序后对应的位置，

用b数组记录，

再按照`id`恢复顺序，按照id动态查找修改



保证每次插入位置为`b[i]`，

由于次序是按照id从前往后，`1~b[i]-1`中只有序号在id之前的会被填充，

于是能找到当前序号在id前有多少个数字满足要求，和为多少



```cpp
struct node
{
    int x,id;
}a[N];

bool cmp(node a,node b)  // 排序
{
    if(a.x<b.x)return true;
    else if(a.x==b.x&&a.id<b.id)return true;
    else return false;
}

bool cmpp(node a,node b)  // 归位
{
    return a.id<b.id;
}

int lowbit(int x){return x&(-x);}

void modify(ll* tr,int x,int k)
{
    for(int i=x;i<=n;i+=lowbit(i))tr[i]+=k;
}

ll qury(ll* tr,int x)
{
    ll ans=0;

    for(int i=x;i;i-=lowbit(i))ans+=tr[i];

    return ans;
}

void solve()
{
    cin>>n;

    for(int i=1;i<=n;i++)
    {
        cin>>a[i].x;

        a[i].id=i;
    }

    sort(a+1,a+n+1,cmp);

    for(int i=1;i<=n;i++)b[a[i].id]=i;

    sort(a+1,a+n+1,cmpp);

    for(int i=1;i<=n;i++)
    {    
        ans+=qury(num,b[i]-1)*a[i].x-qury(sum,b[i]-1);

        modify(num,b[i],1);
        modify(sum,b[i],a[i].x);
    }

    cout<<ans<<endl;
}
```



```cpp
#include <bits/stdc++.h>
#include <functional>

#define alls(a) a.begin(),a.end()
#define emb emplace_back
#define pub push_back
#define pob pop_back
#define puf push_front
#define pof pop_front
#define fi first
#define se second
#define No puts("No")
#define Yes puts("Yes")
#define NO puts("NO")
#define YES puts("YES")

using namespace std;
typedef long long ll;
//typedef __int128 lll; // G++(32位)不支持
typedef unsigned long long ull;
typedef pair<int, int> pii;

const int N = 4e5 + 10;
const int mo = 1e9 + 7;
const int inf = 2e9 + 10;

int n;
ll ans;
int b[N];
ll num[N], sum[N];

struct node
{
	int x, id;
}a[N];

bool cmp(node a, node b)  // 获取当前每个a[i]的排名
{
	if (a.x < b.x)return true;
	else if (a.x == b.x && a.id < b.id)return true;
	else return false;
}

bool cmpp(node a, node b)  // 恢复原样
{
	if (a.id < b.id)return true;
	else return false;
}

inline int lowbit(int x) { return x & (-x); }

void modify(ll* tr, int x, int k)
{
	for (int i = x; i <= n; i += lowbit(i))tr[i] += k;
}

ll qury(ll* tr, int x)
{
	ll ans = 0;

	for (int i = x; i; i -= lowbit(i))ans += tr[i];

	return ans;
}

void solve()
{
	cin >> n;

	for (int i = 1; i <= n; i++)
	{
		cin >> a[i].x;

		a[i].id = i;
	}

	sort(a + 1, a + n + 1, cmp);

	for (int i = 1; i <= n; i++)
	{
		b[a[i].id] = i;  // 记录每个a[i]排序过后的排名
	}

	sort(a + 1, a + n + 1, cmpp);

	// 树状数组动态插入当前a[i]信息
	// 维持原来id不变的情况下，将当前a[i]插入到排完序后的位置

	for (int i = 1; i <= n; i++)
	{
		ans += 1ll * qury(num, b[i] - 1) * a[i].x - 1ll * qury(sum, b[i] - 1);

		modify(num, b[i], 1);
		modify(sum, b[i], a[i].x);
	}

	cout << ans << endl;
}

int main()
{
	int t;

	//cin >> t;

	t = 1;

	while (t--)solve();

	return 0;
}
```
