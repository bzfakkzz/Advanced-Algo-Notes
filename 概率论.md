[0故障 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/2197/learning/)



求在k个故障发生的前提下，每种现象发生的概率



分析：



题中限定k个故障必须发生，其余故障不发生，

用st数组记录当前故障是否发生，

发生就`p[i]*=p[i][j]/100.0`，否则`p[i]*=(1-p[i][j]/100.0)`



```cpp
struct node
{
    double p;
    int idx;

    bool operator<(const node& w)
    {
        if(p>w.p)return true;
        else if(p==w.p&&idx<w.idx)return true;
        else return false;
    }
}a[N];

void solve()
{
    cin>>n>>m;

    for(int i=1;i<=n;i++)cin>>p[i];

    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            cin>>pp[i][j];
        }
    }

    cin>>k;

    for(int i=1;i<=k;i++)
    {
        cin>>x; st[x]=true;
    }

    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(st[j])p[i]*=pp[i][j]/100.0; else p[i]*=(1-pp[i][j]/100.0); //当前现象发生的概率
        }

        sum+=p[i];
    }

    for(int i=1;i<=n;i++)a[i].p=p[i],a[i].idx=i;

    sort(a+1,a+n+1);

    for(int i=1;i<=n;i++)
    {
        printf("%d %.2lf\n",a[i].idx,a[i].p/sum*100);
    }
}
```



```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int N = 110;

int n, m, k;
int x;
bool st[N];
long double p[N], pp[N][N];
long double sum;

struct node
{
    int id;
    long double p;

    bool operator<(const node& t)
    {
        if (p > t.p)return true;
        else if (p == t.p && id < t.id)return true;
        else return false;
    }
}a[N];

int main()
{
    cin >> n >> m;

    for (int i = 1; i <= n; i++)a[i].id = i;

    for (int i = 1; i <= n; i++)cin >> p[i];

    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)cin >> pp[i][j];
    }

    cin >> k;

    for (int i = 1; i <= k; i++)
    {
        cin >> x;

        st[x] = true;
    }

    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            if (st[j])
            {
                p[i] *= pp[i][j] / 100.0;
            }
            else
            {
                p[i] *= (1 - pp[i][j] / 100.0);
            }
        }

        a[i].p = p[i];

        sum += p[i];
    }

    sort(a + 1, a + n + 1);

    for (int i = 1; i <= n; i++)
    {
        printf("%d %.2Lf\n", a[i].id, a[i].p / sum * 100);
    }

    return 0;
}
```
