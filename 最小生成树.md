[E - Clique Connect (atcoder.jp)](https://atcoder.jp/contests/abc352/tasks/abc352_e?lang=en)



给定m个点集和边权，问最小生成树权值为多少



分析：



Kruskal



用node对边权进行排序，

用并查集看当前已经有多少顶点被纳入集合，

从前往后遍历顶点，只要相邻两个点之间没有边就将边纳入生成图中，

用cnt统计纳入了多少边，最小生成树有n-1条边



```cpp
struct node
{
    int id,w;

    bool operator<(const node& W)
    {
        if(w<W.w)return true;
        else if(w==W.w&&id<W.id)return true;
        else return false;
    }
}a[N];

int find(int x)
{
    if(p[x]!=x)p[x]=find(p[x]);

    return p[x];
}

vector<int>e[N];

void solve()
{
    cin>>n>>m;

    for(int i=1;i<=n;i++)
    {
        cin>>k>>a[i].w;

        a[i].id=i;

        e[i].resize(k,0);

        for(auto& u:e[i])cin>>u;
    }

    sort(a+1,a+m+1);

    for(int i=1;i<=n;i++)p[i]=i;

    for(int i=1;i<=m;i++)
    {
        id=a[i].id,w=a[i].w;

        for(int j=0;j<e[id].size()-1;j++)
        {
            aa=e[id][j],bb=e[id][j+1];

            pa=find(aa),pb=find(bb);

            if(pa!=pb)  // 发现当前权值最小边没有被并入连通集
            {
                p[pa]=pb;

                cnt++; ans+=w;  // 并入一条边
            }
        }
    }

    if(cnt==n-1)cout<<ans<<endl; else puts("-1");
}
```



```cpp
#include <bits/stdc++.h>
#include <functional>

#define alls(a) a.begin(),a.end()
#define emb emplace_back
#define pub push_back
#define pob pop_back
#define puf push_front
#define pof pop_front
#define fi first
#define se second
#define No puts("No")
#define Yes puts("Yes")
#define NO puts("NO")
#define YES puts("YES")

using namespace std;
typedef long long ll;
//typedef __int128 lll; // G++(32位)不支持
typedef unsigned long long ull;
typedef pair<int, int> pii;

const int N = 2e5 + 10;
const int mo = 1e9 + 7;
const int inf = 2e9 + 10;

struct node
{
    int w, id;

    bool operator<(const node& W)  // w<W.w
    {
        if (w < W.w)return true;
        else if (w == W.w && id < W.id)return true;
        else return false;
    }
}a[N];

int n, m;
int k, cnt;
int p[N];
ll ans;
vector<int>e[N];

int find(int x)
{
    if (p[x] != x)p[x] = find(p[x]);

    return p[x];
}

void solve()
{
    cin >> n >> m;

    for (int i = 1; i <= n; i++)p[i] = i;

    for (int i = 1; i <= m; i++)
    {
        cin >> k >> a[i].w;

        a[i].id = i;

        e[i].resize(k, 0);

        for (auto& u : e[i])cin >> u;
    }

    sort(a + 1, a + m + 1);  // 将点集编号按权值排序

    int u, w;

    int aa, bb, pa, pb;

    for (int i = 1; i <= m; i++)
    {
        u = a[i].id, w = a[i].w;

        for (int j = 0; j < e[u].size() - 1; j++)  // 按照权值从小到大遍历，只要不在点集里就合并入集合
        {
            aa = e[u][j], bb = e[u][j + 1];

            pa = find(aa), pb = find(bb);

            if (pa != pb)
            {
                p[pa] = pb;

                ans += w;

                cnt++;  // 边数++
            }
        }
    }

    if (cnt == n - 1)cout << ans << endl;
    else puts("-1");
}

int main()
{
    int t;

    //cin >> t;

    t = 1;

    while (t--)solve();

    return 0;
}
```
