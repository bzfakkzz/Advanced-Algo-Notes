[L2-004 这是二叉搜索树吗？ - 团体程序设计天梯赛-练习集 (pintia.cn)](https://pintia.cn/problem-sets/994805046380707840/exam/problems/994805070971912192?type=7&page=0)



分析：



递归判断，二叉搜索树，

前序遍历，根左右，

左边的都<根节点，右边的都>=根节点，满足要求一定能找到唯一的分界点



镜像就是左边的都>=根节点，右边的都<根节点，

用一个f来记录当前check镜像还是原来



```cpp
void check(int l,int r)
{
    if(l>r)return;

    int ll=l+1,rr=r;  // 左子树 右子树

    if(f)
    {
        while(ll<=r&&a[ll]<a[l])ll++;  // 找不满足左子树性质的第一个点

        while(rr>=l&&a[rr]>=a[l])rr--;  // 找不满足右子树性质的第一个点
    }
    else
    {
        while(ll<=r&&a[ll]>=a[l])ll++;

        while(rr>=l&&a[rr]<a[l])rr--;
    }

    if(ll-rr==1)  // 刚好有一个分界线
    {
        check(l+1,ll-1);  // 查左子树

        check(ll,r);

        ans.push_back(a[l]);  // 后序遍历
    }
}

int main()
{
    cin>>n;

    for(int i=1;i<=n;i++)cin>>a[i];

    check(1,n);

    if(ans.size()==n)
    {
        YES;

        for(int i=0;i<n-1;i++)cout<<ans[i]<<' ';

        cout<<ans[n-1];
    }
    else
    {
        f=true; ans.clear(); check(1,n);    

        if(ans.size()==n)
        {    
            YES;

            for(int i=0;i<n-1;i++)cout<<ans[i]<<' '; cout<<ans[n-1];
        }
        else NO;
    }
}
```



```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e3 + 10;

int n;
int a[N];
bool f;
vector<int>v;

void solve(int l, int r)
{
	if (l > r)return;

	int ll = l + 1, rr = r;

	if (f)
	{
		while (ll <= r && a[ll] < a[l])ll++;

		while (rr > l && a[rr] >= a[l])rr--;
	}
	else
	{
		while (ll <= r && a[ll] >= a[l])ll++;

		while (rr > l && a[rr] < a[l])rr--;
	}

	if (ll - rr != 1)return;

	solve(l + 1, rr);

	solve(ll, r);

	v.push_back(a[l]);
}

int main()
{
	cin >> n;

	for (int i = 1; i <= n; i++)cin >> a[i];

	solve(1, n);

	if (v.size() < n)
	{
		v.clear();

		f = true;

		solve(1, n);

		if (v.size() == n)
		{
			puts("YES");

			for (int i = 0; i < v.size() - 1; i++)cout << v[i] << ' ';

			cout << v.back();
		}
		else
		{
			cout << "NO";
		}
	}
	else
	{
		puts("YES");

		for (int i = 0; i < v.size() - 1; i++)cout << v[i] << ' ';

		cout << v.back();
	}

	return 0;
}
```
