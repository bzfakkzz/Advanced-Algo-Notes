[RC-u3 战利品分配 - 2022 RoboCom 世界机器人开发者大赛-本科组（国赛）](https://pintia.cn/problem-sets/1556843855285559296/exam/problems/type/7?problemSetProblemId=1556843936151740418)



当前攻下的城市是**第dist[u]个城市**

判断当前轮到第idx个玩家，用**dist[u]%k==idx%k**，同余于k



```cpp
void solve()
{
    memset(dist,0x3f,sizeof(dist));

    queue<int>q;

    q.push(s);

    st[s]=true;

    dist[s]=1;
    if(dist[s]%k==idx%k)cost[s]+=p[s];

    while(!q.empty())
    {
        x=q.front(); q.pop();

        for(auto u:g[x])
        {
            if(dist[u]>dist[x]+1)
            {
                dist[u]=dist[x]+1; cost[u]=cost[x];
                if(dist[u]%k==idx%k)cost[u]+=p[u];
            }
            else if(dist[u]==dist[x]+1)
            {
                if(dist[u]%k==idx%k)
                {
                    if(cost[u]<cost[x]+p[u])cost[u]=cost[x]+p[u];
                }
                else if(cost[u]<cost[x])cost[u]=cost[x];
            }

            if(!st[u])st[u]=true, q.push(u);
        }
    }

    cout<<cost[t];
}
```



```cpp
#include <bits/stdc++.h>

#define alls(a) a.begin(),a.end()

using namespace std;

const int N = 1e5 + 1;

int x;
int n, m, k, idx;
int u, v;
int p[N];
int s, t;
long long dist[N], cost[N];
bool st[N];
vector<int>g[N];

void solve()
{
    cin >> n >> m >> k >> idx;

    for (int i = 1; i <= n; i++)
    {
        cin >> p[i];
    }

    for (int i = 1; i <= m; i++)
    {
        cin >> u >> v;

        g[u].push_back(v);
        g[v].push_back(u);
    }

    cin >> s >> t;

    for (int i = 1; i <= 1e5; i++)dist[i] = 2e11 + 10;

    dist[s] = 1;

    if (1 % k == idx % k)cost[s] = p[s];
    else cost[s] = 0;

    priority_queue<int, vector<int>, greater<int>>q;

    q.push(s);

    st[s] = true;

    while (!q.empty())
    {
        x = q.top();

        q.pop();

        for (auto u : g[x])
        {
            if (dist[u] > dist[x] + 1)
            {
                dist[u] = dist[x] + 1;
                cost[u] = cost[x];

                if (dist[u] % k == idx % k)cost[u] += p[u];
            }
            else if (dist[u] == dist[x] + 1)
            {
                if (dist[u] % k == idx % k)
                {
                    if (cost[x] + p[u] > cost[u])cost[u] = cost[x] + p[u];
                }
                else
                {
                    if (cost[x] > cost[u])cost[u] = cost[x];
                }
            }

            if (!st[u])
            {
                st[u] = true;

                q.push(u);
            }
        }
    }

    cout << cost[t];
}

int main()
{
    ios::sync_with_stdio(false);

    cin.tie(0);
    cout.tie(0);

    int t = 1;

    //cin >> t;

    while (t--)solve();

    return 0;
}
```



[RC-u4 变牛的最快方法 - 2022 RoboCom 世界机器人开发者大赛-本科组（国赛）](https://pintia.cn/problem-sets/1556843855285559296/exam/problems/type/7?problemSetProblemId=1556843936151740419)



用pre[i][j]记录上一个状态，op[i][j]记录当前操作

f[i][j]：第一个序列**前i个变成**第二个序列**前j个至少需要几次操作**



初始化f[i][0]和f[0][i]，分别只能从删除、插入转换状态



f[i-1][j]+1 删除a[i]

f[i][j-1]+1 插入b[j]

f[i-1][j-1]+(a[i]!=b[j]) 如果a[i]==b[j]不操作，否则更改a[i]



```cpp
memset(f,0x3f,sizeof(f));
memset(op,-1,sizeof(op));

for(int i=1;i<=n1;i++)f[i][0]=i,op[i][0]=0,pre[i][0]={i-1,0};
for(int i=1;i<=n2;i++)f[0][i]=i,op[0][i]=3,pre[0][i]={0,i-1};

f[0][0]=0;

for(int i=1;i<=n1;i++)
{
    for(int j=1;j<=n2;j++)
    {
        op1=f[i-1][j]+1; op2=f[i][j-1]+1; op3=f[i-1][j-1];

        if(a[i]!=b[j])op3++;

        f[i][j]=min(min(op1,op2),op3);

        if(op1==min(min(op1,op2),op3))
        {
            pre[i][j]={i-1,j};
            op[i][j]=0
        }
        else if(op2==min(min(op1,op2),op3))
        {
            pre[i][j]={i,j-1};
            op[i][j]=3;
        }
        else
        {
            pre[i][j]={i-1,j-1};
            if(a[i]==b[j])op[i][j]=2; else op[i][j]=1;
        }
    }

    cout<<f[n1][n2]<<endl;

    cur={n1,n2};

    while(cur!=make_pair(0,0))
    {
        ans.emplace_back(op[cur.fi][cur.se]);

        cur=pre[cur.fi][cur.se];    
    }

    reverse(ans.begin(),ans.end());

    for(auto u:ans)cout<<u;
}
```



```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e3 + 1;

int x;
int n1, n2;
int op1, op2, op3;
vector<int>a, b;
int f[N][N];
int op[N][N];
pair<int, int>pre[N][N];
vector<int>ans;
pair<int, int>cur;

void solve()
{
    a.push_back(0);
    b.push_back(0);

    while (cin >> x, x != -1)
    {
        a.emplace_back(x);

        n1++;
    }

    while (cin >> x, x != -1)
    {
        b.emplace_back(x);

        n2++;
    }

    f[0][0] = 0;

    for (int i = 1; i <= n1; i++)f[i][0] = i, pre[i][0] = { i - 1,0 }, op[i][0] = 0;
    for (int i = 1; i <= n2; i++)f[0][i] = i, pre[0][i] = { 0,i - 1 }, op[0][i] = 3;

    for (int i = 1; i <= n1; i++)
    {
        for (int j = 1; j <= n2; j++)
        {
            op1 = f[i - 1][j] + 1;
            op2 = f[i][j - 1] + 1;
            op3 = f[i - 1][j - 1];

            if (a[i] != b[j])op3++;

            f[i][j] = min(min(op1, op2), op3);

            if (op1 == min(min(op1, op2), op3))
            {
                pre[i][j] = { i - 1,j };

                op[i][j] = 0;
            }
            else if (op2 == min(min(op1, op2), op3))
            {
                pre[i][j] = { i,j - 1 };

                op[i][j] = 3;
            }
            else
            {
                pre[i][j] = { i - 1,j - 1 };

                if (a[i] == b[j])op[i][j] = 2;
                else op[i][j] = 1;
            }
        }
    }

    cout << f[n1][n2] << endl;

    cur.first = n1, cur.second = n2;

    while (true)
    {
        ans.push_back(op[cur.first][cur.second]);

        cur = pre[cur.first][cur.second];

        if (cur == make_pair(0, 0))break;
    }

    reverse(ans.begin(), ans.end());

    for (auto u : ans)cout << u;
}

int main()
{
    int t = 1;

    while (t--)solve();

    return 0;
}
```



[RC-u5 养老社区 - 2022 RoboCom 世界机器人开发者大赛-本科组（国赛）](https://pintia.cn/problem-sets/1556843855285559296/exam/problems/type/7?problemSetProblemId=1556843936151740420)



求任意两点的最短路径，循环选择起始点使用队列进行更新



```cpp
void bfs(int a)
{
    for(int i=1;i<=n;i++)st[i]=false;

    q.push(a);
    st[a]=true;
    f[a][a]=0;

    while(!q.empty())
    {
        x=q.front(); q.pop();

        for(auto u:g[x])
        {
            if(f[a][u]>f[a][x]+1)
            {
                f[a][u]=f[a][x]+1;
            }

            if(!st[u])q.push(u), st[u]=true;
        }
    }
}

void solve()
{
    for(int i=1;i<=n;i++)bfs(i);

    for(int i=1;i<=n;i++)
    {
        for(int j=i+1;j<=n;j++)
        {
            for(int k=j+1;k<=n;k++)
            {
                if(f[i][j]==f[i][k]&&f[j][k]==f[i][j]&&type[i]!=type[j]&&type[i]!=type[k]&&type[j]!=type[k])ans++;
            }
        }
    }

    cout<<ans;
}
```



```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 2e3 + 1;

int n, x;
int u, v;
int f[N][N];
vector<int>g[N];
queue<int>q;
int type[N];
bool st[N];
int ans;

void bfs(int a)
{
    memset(st, 0, sizeof(st));

    f[a][a] = 0;

    q.push(a);

    st[a] = true;

    while (!q.empty())
    {
        x = q.front();

        q.pop();

        for (auto u : g[x])
        {
            if (f[a][u] > f[a][x] + 1)
            {
                f[a][u] = f[a][x] + 1;
            }

            if (!st[u])
            {
                st[u] = true;

                q.push(u);
            }
        }
    }
}

void solve()
{
    cin >> n;

    for (int i = 1; i <= n - 1; i++)
    {
        cin >> u >> v;

        g[u].emplace_back(v);
        g[v].emplace_back(u);
    }

    for (int i = 1; i <= n; i++)
    {
        cin >> type[i];
    }

    memset(f, 0x3f, sizeof(f));

    for (int i = 1; i <= n; i++)
    {
        bfs(i);
    }

    for (int i = 1; i <= n; i++)
    {
        for (int j = i + 1; j <= n; j++)
        {
            for (int k = j + 1; k <= n; k++)
            {
                if (f[i][j] == f[i][k] && f[i][j] == f[j][k] && type[i] != type[j] && type[i] != type[k] && type[j] != type[k])
                {
                    ans++;
                }
            }
        }
    }

    cout << ans;
}

int main()
{
    int t = 1;

    while (t--)solve();

    return 0;
}
```
