[RC-u4 City 不 City - 2024 睿抗机器人开发者大赛CAIP-编程技能赛-本科组（国赛）](https://pintia.cn/problem-sets/1820027446223495168/exam/problems/type/7?problemSetProblemId=1820027610979934211)



dist[i]是点s到i的最小代价

hott[i]是点s到i的沿途热度

通过已经有的点更新其他能到达的点



g[i]储存点i能到达的点

```cpp
for(int i=1;i<=n;i++)
{
    cin>>hot[i];
    if(i==s||i==t)hot[i]=0;  //只算沿途热度，不被计算进去的读入时候直接置为0

    dist[i]=inf;
}

priority_queue<pii,vector<pii>,greater<pii>> q;  // 小根堆
dist[s]=0;
q.push({s,0});

while(!q.empty())
{
    auto t=q.top();  q.pop();
    u=t.x, v=t.y;
    for(auto tt:g[u])
    {
        uu=tt.x, vv=tt.y;

        if(dist[u]+vv<dist[uu])
        {
            dist[uu]=dist[u]+vv;
            q.push_back({uu,dist[uu]});  // 只要是被更新过的更小值，都要更新
            hott[uu]=max(hot[uu],hott[u]);
        }
        else if(dist[u]+vv==dist[uu])
        {
            hott[uu]=min(hott[uu],max(hot[uu],hott[u]));
        }
    }
}
```



```cpp
#include <bits/stdc++.h>

#define pii pair<int,int>

using namespace std;

using ll = long long;

const int N = 1e3 + 10;
const int inf = 2e9 + 10;

int n, m, s, t;
int u, v, c;
int uu, vv;
int hot[N];
int hott[N];  // s到i的沿途hot值
int dist[N];  // s到i的最短距离
vector<pii>g[N];
priority_queue<pii, vector<pii>, greater<pii>>q;

void solve()
{
    cin >> n >> m >> s >> t;

    for (int i = 1; i <= n; i++)
    {
        cin >> hot[i];

        if (i == s || i == t)hot[i] = 0;

        dist[i] = inf;
    }

    for (int i = 1; i <= m; i++)
    {
        cin >> u >> v >> c;

        g[u].push_back({ v,c });
        g[v].push_back({ u,c });
    }

    dist[s] = 0;

    q.push({ s,0 });

    while (!q.empty())
    {
        auto t = q.top();

        q.pop();

        u = t.first, v = t.second;

        for (auto c : g[u])
        {
            uu = c.first, vv = c.second;

            if (v + vv < dist[uu])
            {
                dist[uu] = v + vv;

                q.push({ uu,dist[uu] });

                hott[uu] = max(hott[u], hot[uu]);
            }
            else if (v + vv == dist[uu])
            {
                hott[uu] = min(hott[uu], max(hott[u], hot[uu]));
            }
        }
    }

    if (dist[t] == inf)cout << "Impossible";
    else cout << dist[t] << ' ' << hott[t];
}

int main()
{
    int t = 1;

    // cin>>t;

    while (t--)
    {
        solve();
    }

    return 0;
}
```



[RC-u5 贪心消消乐 - 2024 睿抗机器人开发者大赛CAIP-编程技能赛-本科组（国赛）](https://pintia.cn/problem-sets/1820027446223495168/exam/problems/type/7?problemSetProblemId=1820027610979934212)



我们要求解的x，y分别是列，行，和原本输入的矩阵相反，

输入时也按照列，行读取，处理下落时，记住列，行顺序



每次选择整个区域内获取>0最多分数的区间进行消除，

固定左右边界l，r，枚举下界x，每次更新连续区间中最多分数的最优解



消除方块下落时，枚举每列和下落后的位置，从最后一行开始，选择上方最近的非0方块覆盖当前方块



```cpp
void solve()
{
    cin>>n;

    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            cin>>a[j][i]; if(a[i][j]==0)a[i][j]=-inf;
        }
    }

    while(true)
    {
        maxx=0;

        for(int l=1;l<=n;l++)
        {
            memset(v,0,sizeof(v));

            for(int r=l;r<=n;r++)
            {
                for(int i=1;i<=n;i++)v[i]+=a[i][r]; // 扩充右边界

                cur=0; x=1;

                for(int y=1;y<=n;y++)
                {
                    if(cur<=0)cur=v[y],x=y; // 重新开始连续区间
                    else cur+=v[y];

                    if(cur<=0)continue;

                    if(cur>maxx)
                    {
                        maxx=cur; xx=x,yy=y,ll=l,rr=r;
                    }
                    else if(cur==maxx)
                    {
                        if(x<xx)xx=x,yy=y,ll=l,rr=r;
                        else if(x==xx&&l<ll)xx=x,yy=y,ll=l,rr=r;
                        else if(x==xx&&l==ll&&y<yy)xx=x,yy=y,ll=l,rr=r;
                        else if(x==xx&&l==ll&&y==yy&&r<rr)xx=x,yy=y,ll=l,rr=r;
                    }
                }
            }
        }

        if(maxx<=0)break;

        ans+=maxx;

        cout<<"("<<xx<<", "<<ll<<") ("<<yy<<", "<<rr<<") "<<maxx<<endl;

        for(int i=xx;i<=yy;i++)
        {
            for(int j=ll;j<=rr;j++)a[i][j]=0; // 将被消除的空格置空
        }

        for(int i=1;i<=n;i++)
        {
            for(int j=n;j>=2;j--)
            {
                if(a[i][j]==0)
                {
                    for(int k=j-1;k>=1;k--)
                    {
                        if(a[i][k])
                        {
                            a[i][j]=a[i][k],a[i][k]=0; break; // 填满当前空格
                        }
                    }
                }
            }
        }

        // 多出的空缺被黑洞弥补
        for(int i=1;i<=n;i++)for(int j=1;j<=n;j++){if(a[i][j]==0)a[i][j]=-inf;}
    }

    cout<<ans;
}
```



```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 101;
const int inf = 2e9;

int n;
int a[N][N];
long long s[N];
long long ans, cur, maxx;
int xx, yy, ll, rr;
int be;

void solve()
{
    cin >> n;

    for (int i = 1; i <= n; i++) 
    {
        for (int j = 1; j <= n; j++)
        {
            cin >> a[j][i];

            if (a[j][i] == 0)a[j][i] = -inf;
        }
    }

    while (true)
    {
        maxx = 0;

        for (int l = 1; l <= n; l++)
        {
            memset(s, 0, sizeof(s));

            for (int r = l; r <= n; r++)
            {
                for (int i = 1; i <= n; i++)s[i] += a[i][r];

                cur = 0;

                for (int x = 1; x <= n; x++)
                {
                    if (cur <= 0)
                    {
                        cur = s[x];

                        be = x;
                    }
                    else cur += s[x];

                    if (cur <= 0)continue;

                    if (cur > maxx)
                    {
                        maxx = cur;
                        xx = be;
                        yy = x;
                        ll = l;
                        rr = r;
                    }
                    else if (cur == maxx)
                    {
                        if (be < xx)
                        {
                            xx = be;
                            yy = x;
                            ll = l;
                            rr = r;
                        }
                        else if (be == xx && l < ll)
                        {
                            xx = be;
                            yy = x;
                            ll = l;
                            rr = r;
                        }
                        else if (be == xx && l == ll && x < yy)
                        {
                            xx = be;
                            yy = x;
                            ll = l;
                            rr = r;
                        }
                        else if (be == xx && l == ll && x == yy && r < rr)
                        {
                            xx = be;
                            yy = x;
                            ll = l;
                            rr = r;
                        }
                    }
                }
            }
        }

        if (maxx <= 0)break;

        ans += maxx;

        cout << "(" << xx << ", " << ll << ") (" << yy << ", " << rr << ") " << maxx << endl;

        for (int i = xx; i <= yy; i++)
        {
            for (int j = ll; j <= rr; j++)
            {
                a[i][j] = 0;
            }
        }

        for (int i = 1; i <= n; i++)
        {
            for (int j = n; j >= 2; j--)
            {
                if (a[i][j] == 0)
                {
                    for (int k = j - 1; k >= 1; k--)
                    {
                        if (a[i][k])
                        {
                            a[i][j] = a[i][k];
                            a[i][k] = 0;

                            break;
                        }
                    }
                }
            }
        }

        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                if (a[i][j] == 0)a[i][j] = -inf;
            }
        }
    }

    cout << ans;
}

int main()
{
    int t = 1;

    while (t--)solve();

    return 0;
}
```



<img title="" src="file:///D:/ACM/%E9%94%99%E9%A2%98%E6%95%B4%E7%90%86/pictures/24_5.png" alt="" data-align="center" style="zoom:50%;">
