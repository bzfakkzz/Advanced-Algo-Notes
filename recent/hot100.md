[139. 单词拆分 - 力扣（LeetCode）](https://leetcode.cn/problems/word-break/?envType=problem-list-v2&envId=2cktkvj)



`f[i]`表示到下标为i为止都能拼成，每次枚举分割点j



```cpp
class Solution {
    const static int N=301;
    map<string,bool> mp;
    bool f[N];
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        memset(f,0,sizeof(f));
        for(auto u:wordDict)mp[u]=true;

        s=" "+s;
        f[0]=true; // 起点初始化为true

        for(int i=1;i<s.size();i++)
        {
            for(int j=0;j<i;j++)
            {
                if(f[j]&&mp[s.substr(j+1,i-j)]==true)
                {
                    f[i]=true; break;
                }
            }
        }

        return f[s.size()-1];  // 看这个下标能不能到达
    }
};
```



[146. LRU 缓存 - 力扣（LeetCode）](https://leetcode.cn/problems/lru-cache/description/?envType=problem-list-v2&envId=2cktkvj)



懒出队：

开一个cnt数组记录你是否次数为0（完全被消灭）

只有次数为0才让你出队，额外用一个变量记录当前队有多少元素



只要被用到都入队q



```cpp
class LRUCache {
    const static int N=1e4+1;
    int n,cur;
    queue<int>q;
    int time[N],mp[N];
public:
    LRUCache(int capacity) {
        n=capacity;
        cur=0;
        for(int i=0;i<N;i++)time[i]=0;
    }
    
    int get(int key) {
        if(!time[key])return -1;
        time[key]++;
        return mp[key];
    }
    
    void put(int key, int value) {
        if(!time[key])cur++;

        q.push(key);
        time[key]++;
        mp[key]=value;

        while(cur>n)
        {
            time[q.front()]--;
            if(time[q.front()]==0)cur--;

            q.pop();
        }
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```



[152. 乘积最大子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-product-subarray/description/?envType=problem-list-v2&envId=2cktkvj)



最大：

1. 负数×负数（我们需要统计minn）

2. 正数×正数（我们需要统计maxx）

3. 本身是正数



最小：

1. 负数×正数

2. 正数×负数

3. 本身是负数



`maxx[i]`表示以i结尾的子数组乘积最大值

`minn[i]`表示以i结尾的子数组乘积最小值



```cpp
class Solution {
    const int N=2e4+1;
    int ans;
    int maxx,minn;
public:
    int maxProduct(vector<int>& nums) {
        maxx=1;
        minn=1;
        ans=nums[0];

        for(int i=0;i<nums.size();i++)
        {
            maxx=max(max(nums[i],maxx*f[i]),minn*f[i]);
            minn=min(min(nums[i],maxx*f[i]),minn*f[i]);

            ans=max(ans,maxx);
        }

        return ans;
    }
};
```



[155. 最小栈 - 力扣（LeetCode）](https://leetcode.cn/problems/min-stack/description/?envType=problem-list-v2&envId=2cktkvj)



要求存放最小值，

直接用`pair<int,int>`存放当前节点 + 到当前节点为止的最小值



```cpp
class MinStack {
    stack<pair<int,int>>stk;
public:
    MinStack() {}

    void push(int val) {
        if(stk.empty())stk.push({val,val});
        else stk.push({val,min(val,stk.top().second});
    }

    void pop() {
        if(!stk.empty())stk.pop();
    }

    int top() {
        return stk.top().first;
    }

    int getMin() {
        return stk.top().second;
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */
```



[238. 除自身以外数组的乘积 - 力扣（LeetCode）](https://leetcode.cn/problems/product-of-array-except-self/?envType=problem-list-v2&envId=2cktkvj)



a数组是从前往后乘，b数组是从后往前乘

`ans[i]=a[i-1]*b[i+1]`，不乘`nums[i]`

<img title="" src="file:///D:/ACM/%E9%94%99%E9%A2%98%E6%95%B4%E7%90%86/pictures/czsywszdcj1.png" alt="" data-align="center" style="zoom:50%;">

```cpp
class Solution {
    const static int N=1e5+1;
    int a[N],b[N];
    vector<int>ans;
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        for(int i=0;i<nums.size();i++)
        {
            if(i==0)a[i]=nums[i];
            else a[i]=a[i-1]*nums[i];
        }

        for(int i=nums.size()-1;i>=0;i--)
        {
            if(i==nums.size()-1)b[i]=nums[i];
            else b[i]=b[i+1]*nums[i];
        }

        for(int i=0;i<nums.size();i++)
        {
            if(i==0)ans.emplace_back(b[1]);
            else if(i==nums.size()-1)ans.emplace_back(a[nums.size()-2]);
            else ans.emplace_back(a[i-1]*b[i+1]);  // 中间的不要乘
        }

        return ans;
    }
};
```



[206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/description/?envType=problem-list-v2&envId=2cktkvj)



每次走一个节点，将当前链表反转



```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* p=NULL;
        auto q=head;
        auto cur=q;

        while(q!=NULL)
        {
            cur=q->next;
            q->next=p;
            p=q; q=cur;
        }

        return p;
    }
};
```



[207. 课程表 - 力扣（LeetCode）](https://leetcode.cn/problems/course-schedule/?envType=problem-list-v2&envId=2cktkvj)



图论，st数组用于标记当前节点是否被找过/是否是中间节点



```cpp
class Solution {
    const static int N=2e3+1;
    vector<short>e[N];
    short st[N];
    bool f;
public:
    void dfs(int cur){
        st[cur]=1;

        for(auto u:e[cur])
        {
            if(st[u]==0)
            {
                dfs(u);
            }
            else if(st[u]==1)
            {
                f=false; return;
            }
        }

        st[cur]=2;  // 出口，标记当前节点是中间节点（已经被找过）
    }

    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        f=true;

        for(auto u:prerequisites)
        {
            e[u[0]].emplace_back(u[1]);
        }

        for(int i=0;i<numCourses;i++)
        {
            if(st[u]==0){
                dfs(u);

                if(f==false)return false;
            }
        }

        return true;
    }
};
```



[208. 实现 Trie (前缀树) - 力扣（LeetCode）](https://leetcode.cn/problems/implement-trie-prefix-tree/?envType=problem-list-v2&envId=2cktkvj)



将每个字符串都用idx标号

判断是否为前缀：是否有当前结尾的字符串



```cpp
class Trie {
    vector<vector<short>>tr;
    vector<bool>cnt;
    int idx;
public:
    Trie() {
        tr.push_back(vector<short>(26,0));
        idx=0;
        cnt.push_back(false);
    }

    void insert(string word) {
        int p=0;  // 从第0层开始
        int u=0;

        for(int i=0;i<word.size();i++)
        {
            u=word[i]-'a';

            if(!tr[p][u]) // idx++，开辟新的一层，tr[p][u]，p就是idx
            {
                tr.push_back(vector<short>(26,0));
                cnt.emplace_back(0);
                tr[p][u]=++idx;
            }

            p=tr[p][u];
        }

        cnt[p]=true;
    }

    bool search(string word) {
        int p=0;
        int u=0;

        for(int i=0;i<word.size();i++)
        {
            u=word[i]-'a';

            if(tr.size()<p+1||!tr[p][u])return false;

            p=tr[p][u];
        }

        if(!cnt[p])return false;

        return true;
    }

    bool startsWith(string prefix) {
        int p=0;
        int u=0;

        for(int i=0;i<prefix.size();i++)
        {
            u=prefix[i]-'a';

            if(tr.size()<p+1||!tr[p][u])return false;

            p=tr[p][u];
        }

        return true;
    }
};
```



[221. 最大正方形 - 力扣（LeetCode）](https://leetcode.cn/problems/maximal-square/?envType=problem-list-v2&envId=2cktkvj)



二分会超时，$O( N^4\log N)$，最坏情况下每个小方块都要扫一遍



`f[i][j]=min(f[i-1][j],f[i][j-1],f[i-1][j-1])+1`

要拓展正方形，需要将当前方格作为右下角，3个方向取min+1

<img title="" src="file:///D:/ACM/%E9%94%99%E9%A2%98%E6%95%B4%E7%90%86/pictures/zdzfx2.png" alt="" data-align="center" style="zoom:50%;">

<img title="" src="file:///D:/ACM/%E9%94%99%E9%A2%98%E6%95%B4%E7%90%86/pictures/zdzfx1.png" alt="" data-align="center" style="zoom:50%;">

```cpp
class Solution {
public:
    const static int N=301;
    int f[N][N];
    int maxx;

    int maximalSquare(vector<vector<char>>& matrix) {
        for(int i=0;i<matrix.size();i++)
        {
            for(int j=0;j<matrix[0].size();j++)
            {
                if(matrix[i][j]=='1')
                {
                    f[i+1][j+1]=min(min(f[i][j+1],f[i+1][j]),f[i][j])+1;

                    maxx=max(maxx,f[i+1][j+1]);
                }
            }
        }

        return maxx*maxx;
    }
};
```



[739. 每日温度 - 力扣（LeetCode）](https://leetcode.cn/problems/daily-temperatures/description/?envType=problem-list-v2&envId=2cktkvj)



用栈储存节点，能保证栈中存储的都是还没有遇到更高温度的数



如：

3 2 4 6 5 4 2 1 7

栈：3 2

遇：4

清空栈，放入4

栈：4

遇：6

清空栈，放入6

栈：6 5 4 2 1

遇：7

清空栈，放入7



栈中是一个单调递减序列，能消除的都会消除，不会遇到3 9 6这种无法消除的情况



```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        vector<int>a=vector<int>(temperatures.size(),0);

        stack<int>stk;

        for(int i=0;i<temperatures.size();i++)
        {
            while(!stk.empty()&&temperatures[i]>temperatures[stk.top()])
            {
                a[stk.top()]=i-stk.top();

                stk.pop();
            }

            stk.push(i);
        }

        return a;
    }
};
```



[236. 二叉树的最近公共祖先 - 力扣（LeetCode）](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/?envType=problem-list-v2&envId=2cktkvj)



递归：假设已经得到答案



基线条件（可以直接得到的答案）：

1. 当前树为空

2. root就是p/q
   
   

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root==NULL||root==p||root==q)return root;

        auto left=lowestCommonAncestor(root->left,p,q);  // 假设已经找到左子树中包含p或q的节点
        auto right=lowestCommonAncestor(root->right,p,q);

        if(left&&right)return root;  // p，q分别在左右

        if(left)return left;
        else return right;
    }
};
```



[160. 相交链表 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-linked-lists/description/?envType=problem-list-v2&envId=2cktkvj)



两个指针，每走一步就共同移动一步

走完当前边就从另一个图开始，m+n==n+m，一定能相遇

遇到的点就是交点

<img title="" src="file:///D:/ACM/%E9%94%99%E9%A2%98%E6%95%B4%E7%90%86/pictures/hot1_1.png" alt="" data-align="center" style="zoom:50%;">

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {
        auto p=headA;
        auto q=headB;

        if(p==NULL||q==NULL)return NULL;

        while(p!=q)
        {
            p=(p==NULL)?headB:p->next;
            q=(q==NULL)?headA:q->next;
        }

        return p;
    }
};
```



[236. 二叉树的最近公共祖先 - 力扣（LeetCode）](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/?envType=problem-list-v2&envId=2cktkvj)



基线条件：只有一个节点/空树，直接返回

递归是假设已经能实现查找了，然后再查找



三种情况：

1. 只在左子树

2. 只在右子树

3. 左右子树都有
   
   

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root==NULL||root==p||root==q)return root;

        auto left=lowestCommonAncestor(root->left,p,q);
        auto right=lowestCommonAncestor(root->right,p,q);

        if(left&&right)return root;

        if(left)return left;
        else return right;
    }
};
```
