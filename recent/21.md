[7-2 队列插入 - 2021 RoboCom 世界机器人开发者大赛-本科组（决赛）](https://pintia.cn/problem-sets/1459838995685031936/exam/problems/type/7?problemSetProblemId=1459839106574675969)



要求最长上升子序列长度最大的前提下，字典序最小



能让字典序变大的是R，枚举R开始的位置求最长上升子序列

除了哪些R之外，全是L，求能接在R前面的最长上升子序列



更新的逻辑：

大于f[len]的接在队尾，否则就看能否是更小的某个上升子序列的队尾，

便于后续接更多数字

```cpp
if(len==0)f[++len]=a[j],g[j]=len;
else if(f[len]<a[j])f[++len]=a[j],g[j]=len;
else if(a[j]>f[1])  // 选择以a[i]作为开头，f[1]只能是a[i]
{
    idx=lower_bound(f+1,f+len+1,a[j])-f;
    f[idx]=a[j];
    g[j]=idx;
}
```



```cpp
void solve()
{
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];

    for(int i=1;i<=n+1;i++)  // 可能全L，此时R为n+1
    {
        len=0;

        for(int j=i;j<=n;j++)
        {
            if(len==0)f[++len]=a[j],g[j]=len;
            else if(a[j]>f[len])f[++len]=a[j],g[j]=len;
            else if(a[j]>f[1])
            {
                idx=lower_bound(f+1,f+len+1,a[j])-f;
                f[idx]=a[j];
                g[j]=len;
            }
        }

        cur=len; vec.clear();

        for(int j=n;j>=i;j--)
        {
            if(cur&&g[j]==cur)vec.push_back(j),cur--;

            g[j]=0;
        }

        reverse(alls(vec));  // 恢复顺序坐标

        for(auto u:vec)st[u]=true;

        len1=0; x=f[1];

        if(len==0)x=inf;

        for(int j=n;j>=1;j--)
        {
            if(st[u])
            {
                st[u]=0; continue;
            }

            if(len1==0&&a[j]<x)f[++len1]=a[j];
            else if(a[j]<x)  // 接在后面
            {
                if(a[j]>f[len1])f[++len1]=a[j];
                else
                {
                    idx=lower_bound(f+1,f+len1+1,a[j])-f;
                    f[idx]=a[j];
                }
            }
        }

        if(len1+len>len2)
        {
            len2=len+len1;
            ans=vec;
        }
        else if(len1+len==len2)
        {
            if(ans.size()==0)continue;
            else if(vec.size()==0)ans=vec;
            else if(vec<ans)ans=vec;  // 比较字典序
        }
    }

    cout<<len2<<endl;
    for(auto u:ans)st[u]=1;
    for(int i=1;i<=n;i++)
    {
        if(st[i])cout<<'R'; else cout<<'L';
    }
}
```



```cpp
#include <bits/stdc++.h>

#define ll long long

using namespace std;

const int N = 1e3 + 1;
const ll inf = 2e10;

int n;
ll x;
int len, len1, len2, idx, cur;
int a[N];
int f[N], cnt[N];
bool ans[N];
vector<int>vec, vecc;

void solve()
{
    cin >> n;

    for (int i = 1; i <= n; i++)cin >> a[i];

    for (int i = 1; i <= n + 1; i++)
    {
        len = 0;

        for (int j = i; j <= n; j++)
        {
            if (len == 0)f[++len] = a[j], cnt[j] = 1;
            else if (a[j] > f[len])f[++len] = a[j], cnt[j] = len;
            else if (a[j] > f[1])
            {
                idx = lower_bound(f + 1, f + len + 1, a[j]) - f;
                f[idx] = a[j];
                cnt[j] = idx;
            }
        }

        vec.clear();

        cur = len;

        for (int j = n; j >= 1; j--)
        {
            if (cnt[j] == cur && cur)vec.emplace_back(j), cur--;

            cnt[j] = 0;
        }

        reverse(vec.begin(), vec.end());

        for (auto u : vec)ans[u] = 1;

        x = f[1];

        if (len == 0)x = inf;

        len1 = 0;

        for (int j = n; j >= 1; j--)
        {
            if (ans[j])
            {
                ans[j] = 0;
                continue;
            }

            if (len1 == 0 && a[j] < x)f[++len1] = a[j];
            else if (a[j] < x)
            {
                if (a[j] > f[len1])
                {
                    f[++len1] = a[j];
                }
                else
                {
                    idx = lower_bound(f + 1, f + len1 + 1, a[j]) - f;
                    f[idx] = a[j];
                }
            }
        }

        if (len + len1 > len2)
        {
            len2 = len + len1;
            vecc = vec;
        }
        else if (len + len1 == len2)
        {
            if (vecc.size() == 0)continue;
            if (vec.size() == 0)vecc = vec;
            else if (vecc < vec)vecc = vec;
        }
    }

    cout << len2 << endl;

    for (auto u : vecc)ans[u] = 1;

    for (int i = 1; i <= n; i++)
    {
        if (ans[i])cout << 'R';
        else cout << 'L';
    }
}

int main()
{
    int t = 1;

    while (t--)solve();

    return 0;
}
```



[7-4 猛犸不上 Ban - 2021 RoboCom 世界机器人开发者大赛-本科组（决赛）](https://pintia.cn/problem-sets/1459838995685031936/exam/problems/type/7?problemSetProblemId=1459839106574675971)



分别求从s开始绕环回到s之后的最短路，从s出发到t的最短路



ans1是d[u1][u2]+v1+v2，其中u1，u2是s的邻结点

ans2就是普通的最短路



```cpp
void solve()
{
    cin>>n>>m>>s>>t;

    for(int i=1;i<=m;i++)
    {
        cin>>x>>y>>v;

        g[x].push_back({y,v});
        g[y].push_back({x,v});
    }

    ans1=ans2=inf;

    memset(dist,0x3f,sizeof(dist));

    queue<int>q;

    q.push(s); dist[s]=0; st[s]=true;

    while(!q.empty())
    {
        x=q.front(); st[x]=false; q.pop();

        for(auto u:g[x])
        {
            if(dist[u.first]>dist[x]+u.second)
            {
                dist[u.first]=dist[x]+u.second;

                if(!st[u.first]){st[u.first]=true; q.push(u.first);}
            }
        }
    }

    ans2=dist[t];

    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)d[i][j]=inf;

    for(int i=1;i<=n;i++)d[i][i]=0;

    for(int i=1;i<=n;i++)
    {
        if(i==s)continue;

        for(auto u:g[i])
        {
            if(u.first==s)continue;

            d[i][u.first]=u.second;
        }
    }

    for(int k=1;k<=n;k++)
    {
        if(k==s)continue;
        for(int i=1;i<=n;i++)
        {
            if(i==s)continue;
            for(int j=1;j<=n;j++)
            {
                if(j==s)continue;

                if(d[i][k]!=inf&&d[k][j]!=inf)d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
            }
        }    
    }

    for(int i=0;i<g[s].size();i++)
    {
        for(int j=i+1;j<g[s].size();j++)
        {
            x1=g[s][i].first; v1=g[s][i].second;
            x2=g[s][j].first; v2=g[s][j].second;

            if(d[x1][x2]==inf)continue;

            ans1=min(ans1,d[x1][x2]+v1+v2);
        }
    }

    cout<<(ans1==inf?-1:ans1)<<' '<<(ans2==inf?-1:ans2)<<endl;

    if(ans1<ans2)cout<<"Win!";
    else cout<<"Lose!";
}
```





```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 500 + 1;
const int inf = 0x3f3f3f3f;

int n, m, s, t;
int x, y, v;
int d[N][N];
bool st[N];
int dist[N];
vector<pair<int, int>>g[N];
vector<pair<int, int>>a;
int dist1, dist2;
queue<int>q;

void solve()
{
    cin >> n >> m >> s >> t;

    for (int i = 1; i <= m; i++)
    {
        cin >> x >> y >> v;

        g[x].push_back({ y,v });
        g[y].push_back({ x,v });
    }

    memset(dist, 0x3f, sizeof(dist));

    q.push(s);
    st[s] = true;
    dist[s] = 0;

    while (!q.empty())
    {
        x = q.front();

        q.pop();

        for (auto u : g[x])
        {
            y = u.first;
            v = u.second;

            if (dist[y] > dist[x] + v)
            {
                dist[y] = dist[x] + v;
            }

            if (!st[y])
            {
                st[y] = true;

                q.push(y);
            }
        }
    }

    dist2 = dist[t];

    dist1 = inf;

    memset(d, 0x3f, sizeof(d));

    for (int i = 1; i <= n; i++)d[i][i] = 0;

    for (auto u : g[s])
    {
        a.push_back({ u.first,u.second }); // s作为中转点
    }

    for (int i = 1; i <= n; i++)
    {
        if (i == s)continue;

        for (auto u : g[i])
        {
            if (u.first == s)continue;

            d[i][u.first] = u.second;
        }
    }

    // 每次必须考虑所有点对 (i,j) 通过 k 更新的可能性
    for (int k = 1; k <= n; k++)
    {
        if (k == s)continue;

        for (int j = 1; j <= n; j++)
        {
            if (j == s)continue;

            for (int i = 1; i <= n; i++)
            {
                if (i == s)continue;

                if (d[i][k] != inf && d[k][j] != inf)
                {
                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
                }
            }
        }
    }

    for (int i = 0; i < a.size(); i++)
    {
        for (int j = i + 1; j < a.size(); j++)
        {
            if (d[a[i].first][a[j].first] != inf)
            {
                dist1 = min(dist1, a[i].second + a[j].second + d[a[i].first][a[j].first]);
            }
        }
    }

    if (dist1 > 1e7 && dist2 > 1e7)cout << "-1";
    else
    {
        if (dist1 > 1e7)
        {
            cout << -1 << ' ' << dist2;
        }
        else if (dist2 > 1e7)
        {
            cout << dist1 << ' ' << -1;
        }
        else
        {
            cout << dist1 << ' ' << dist2;
        }

        cout << endl;

        if (dist1 < dist2)cout << "Win!";
        else cout << "Lose!";
    }
}

int main()
{
    int t = 1;

    while (t--)solve();

    return 0;
}
```
