[RC-u2 桌游猜谜 - 2023 睿抗机器人开发者大赛CAIP-编程技能赛-本科组（国赛）](https://pintia.cn/problem-sets/1693095794755289088/exam/problems/type/7?problemSetProblemId=1693095890628689921)



n个人给出每个颜色有的牌，对于每个颜色，还剩下8-n种方案

当前手中选取3种颜色持有牌的方案有pow(8-n, 3)种



基于回答，当前牌总和确定区间[L, R]范围剩余的可能方案有MAX(K1, K2)种



确定了**牌色**，**总和区间**，剩余的可能方案总共有pow(8-n, 3)*MAX(K1, K2)种



```cpp
void dfs(int c1,int c2,int c3,int cnt,int l,int r,int sum)
{
    if(cnt>=3)
    {
        if(sum>=l&&sum<=r)kk1++; else kk2++;

        return;
    }

    int x;

    if(cnt==0)x=c1;
    else if(cnt==1)x=c2;
    else x=c3;

    for(int i=1;i<=8;i++)
    {
        if(!st[x][i])
        {
           st[x][i]=true; dfs(c1,c2,c3,cnt+1,l,r,sum+i); st[x][i]=false; 
        }
    }
}
```



```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 10;

int n, x;
bool st[N][N];
int ans;
int k1, k2, kk1, kk2;

int qpow(int a, int b)
{
    int res = 1;

    while (b)
    {
        if (b & 1)res *= a;

        a *= a;

        b >>= 1;
    }

    return res;
}

void dfs(int c1, int c2, int c3, int cnt, int l, int r, int sum)
{
    if (cnt >= 3)
    {
        if (sum >= l && sum <= r)kk1++;
        else kk2++;

        return;
    }

    int x;

    if (cnt == 0)x = c1;
    else if (cnt == 1)x = c2;
    else x = c3;

    for (int i = 1; i <= 8; i++)
    {
        if (!st[x][i])
        {
            st[x][i] = true;

            dfs(c1, c2, c3, cnt + 1, l, r, sum + i);

            st[x][i] = false;
        }
    }
}

void solve()
{
    cin >> n;

    k1 = k2 = kk1 = kk2 = 0;

    ans = qpow(8 - n, 3);

    for (int i = 0; i < 10; i++)
    {
        for (int j = 0; j < 10; j++)
        {
            st[i][j] = false;
        }
    }

    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= 6; j++)
        {
            cin >> x;

            st[j][x] = true;
        }
    }

    for (int i = 1; i <= 6; i++)
    {
        for (int j = i + 1; j <= 6; j++)
        {
            for (int k = j + 1; k <= 6; k++)
            {
                for (int l = 3; l <= 24; l++)
                {
                    for (int ll = l; ll <= 24; ll++)
                    {
                        kk1 = kk2 = 0;

                        dfs(i, j, k, 0, l, ll, 0);

                        if (min(kk1, kk2) > min(k1, k2))
                        {
                            k1 = kk1;
                            k2 = kk2;
                        }
                        else if (min(kk1, kk2) == min(k1, k2) && kk1 > k1)
                        {
                            k1 = kk1;
                            k2 = kk2;
                        }
                        else if (min(kk1, kk2) == min(k1, k2) && kk2 > k2)
                        {
                            k1 = kk1;
                            k2 = kk2;
                        }
                    }
                }
            }
        }
    }

    ans *= max(k1, k2);

    std::cout << ans << endl;
}

int main()
{
    int t = 1;

    cin >> t;

    while (t--)solve();

    return 0;
}
```



[RC-u4 拆积木 - 2023 睿抗机器人开发者大赛CAIP-编程技能赛-本科组（国赛）](https://pintia.cn/problem-sets/1693095794755289088/exam/problems/type/7?problemSetProblemId=1693095890628689923)



要想拿去一块积木，就要等上方没有别的积木



入度d[i]为0时才能拿去当前积木

用单链表存储拿去当前积木时会减少入度的积木



```cpp
void add(int a,int b)
{
    e[idx]=b; ne[idx]=h[a]; h[a]=idx++;
}

void solve()
{
    cin>>n>>m>>k;

    for(int i=1;i<=n;i++){for(int j=1;j<=m;j++)cin>>g[i][j];}

    for(int i=2;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(g[i-1][j]==g[i][j])continue;

            add(g[i-1][j],g[i][j]); // g[i][j]依赖g[i-1][j]，只有上面被抽走才能抽当前木块
            d[g[i][j]]++;
        }
    }    

    for(int i=1;i<=m;i++)
    {
        if(!st[g[1][i]]&&d[g[1][i]]==0){st[g[1][i]]=true; q.push(g[1][i]);}
    }

    while(!q.empty())
    {
        x=q.top(); q.pop();

        if(cnt==0)cout<<x;
        else cout<<' '<<x;

        cnt++;

        for(int i=h[x];i!=-1;i=ne[i]){d[e[i]]--; if(d[e[i]]==0)q.push(e[i]);}
    }

    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(d[g[i][j]])
            {
                if(cnt==0)cout<<"Impossible";
                else cout<<" Impossible";
            }
        }
    }
}
```



```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e3 + 10;
const int M = 1e6 + 1;

int cnt, x;
int n, m, idx;
int g[N][N];
int d[M];
int e[M], h[M], ne[M];
bool st[M];
priority_queue<int, vector<int>, greater<int>>q;

void add(int a, int b)
{
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

void solve()
{
    cin >> n >> m;

    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            cin >> g[i][j];
        }
    }

    memset(h, -1, sizeof(h));
    memset(ne, -1, sizeof(ne));

    for (int i = 2; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            if (g[i - 1][j] == g[i][j])continue;
            else
            {
                add(g[i - 1][j], g[i][j]);

                d[g[i][j]]++;
            }
        }
    }

    for (int i = 1; i <= m; i++)
    {
        if (d[g[1][i]] == 0 && !st[g[1][i]])
        {
            q.push(g[1][i]);

            st[g[1][i]] = true;
        }
    }

    while (!q.empty())
    {
        x = q.top();

        q.pop();

        if (!cnt)cout << x;
        else cout << ' ' << x;

        cnt++;

        for (int i = h[x]; ~i; i = ne[i])
        {
            d[e[i]]--;

            if (d[e[i]] == 0)q.push(e[i]);
        }
    }

    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            if (d[g[i][j]])
            {
                if (!cnt)cout << "Impossible";
                else cout << " Impossible";

                return;
            }
        }
    }
}

int main()
{
    int t = 1;

    // cin>>t;

    ios::sync_with_stdio(false);

    cin.tie(0);

    while (t--)solve();

    return 0;
}
```



[RC-u5 栈与数组 - 2023 睿抗机器人开发者大赛CAIP-编程技能赛-本科组（国赛）](https://pintia.cn/problem-sets/1693095794755289088/exam/problems/type/7?problemSetProblemId=1693095890628689924)



每k个相同数字可以被消除，cur[i][j]表示放入i个栈1和j个栈2后占用的位置

当前引入元素是在前一个状态基础上增加元素，cur[i][0]=cur[i-1][0]+1



f[i][j]表示在当前数组容量下，**是否能放入**i个栈1和j个栈2

f[i][j]从f[i-1][j]或f[i][j-1]转移过来，当前占用位置cur[i][j-1]+1或cur[i+1][j]



二分枚举数组长度



```cpp
bool check(int len)
{
    memset(f,0,sizeof(f));

    f[0][0]=true;

    for(int i=1;i<=c1;i++)
    {
        if(f[i-1][0]&&cur[i-1][0]+1<=len)f[i][0]=true;
    }

    for(int i=1;i<=c2;i++)
    {
        if(f[0][i-1]&&cur[0][i-1]+1<=len)f[0][i]=true;
    }

    for(int i=1;i<=c1;i++)
    {
        for(int j=1;j<=c2;j++)
        {
            if(f[i-1][j]&&cur[i-1][j]+1<=len)f[i][j]=true;
            else if(f[i][j-1]&&cur[i][j-1]+1<=len)f[i][j]=true;
        }
    }

    return f[c1][c2]; // 是否能到达终点
}

void solve()
{
    for(int i=1;i<=c1;i++)cin>>a[i];
    for(int i=1;i<=c2;i++)cin>>b[i];

    for(int i=1;i<=c1;i++)
    {
        mp[a[i]]++; cur[i][0]=cur[i-1][0]+1; //*

        if(mp[a[i]]%k==0)cur[i][0]-=k;
    }

    mp.clear();

    for(int i=0;i<=c1;i++)
    {
        if(i!=0)mp[a[i]]++; //*

        for(int j=1;j<=c2;j++)
        {
            mp[b[j]]++; cur[i][j]=cur[i][j-1]+1;

            if(mp[b[j]]%k==0)cur[i][j]-=k;
        }

        for(int j=1;j<=c2;j++)
        {
            mp[b[j]]--;
        }
    }

    l=k, r=c1+c2;

    while(l<r)
    {
        mid=(l+r)>>1;

        if(check(mid))r=mid; else l=mid+1;
    }

    cout<<l<<endl;
}
```





```cpp
#include <bits/stdc++.h>

#include <unordered_map>

#define pii pair<int,int>

using namespace std;

const int N = 1e3 + 10;

int x;
int c1, c2, k;
int l, r, mid;
int a[N], b[N];
int cur[N][N];  // 放了i个，j个之后剩余留在数组中的个数
int curr[N];
bool f[N][N];
unordered_map<int, int>mp;

bool check(int len)
{
    memset(f, 0, sizeof(f));

    f[0][0] = true;

    for (int i = 1; i <= c1; i++)
    {
        if (f[i - 1][0] && cur[0][i - 1] + 1 <= len)f[i][0] = true;
    }

    for (int j = 1; j <= c2; j++)
    {
        if (f[0][j - 1] && cur[0][j - 1] + 1 <= len)f[0][j] = true;
    }

    // 从任意一个栈顶取出一个数字放置在数组的任意空位
    for (int i = 1; i <= c1; i++)
    {
        for (int j = 1; j <= c2; j++)
        {
            if (f[i - 1][j] && cur[i - 1][j] + 1 <= len)f[i][j] = true;
            else if (f[i][j - 1] && cur[i][j - 1] + 1 <= len)f[i][j] = true;
        }
    }

    return f[c1][c2];
}

void solve()
{
    cin >> c1 >> c2 >> k;

    mp.clear();

    memset(cur, 0, sizeof(cur));
    memset(curr, 0, sizeof(curr));

    for (int i = 1; i <= c1; i++)cin >> a[i];
    for (int i = 1; i <= c2; i++)cin >> b[i];

    for (int i = 1; i <= c1; i++)
    {
        mp[a[i]]++;

        curr[i] = curr[i - 1] + 1;

        if (mp[a[i]] % k == 0)
        {
            curr[i] -= k;
        }
    }

    mp.clear();

    for (int i = 1; i <= c1; i++)
    {
        cur[i][0] = curr[i];
    }

    for (int i = 0; i <= c1; i++)
    {
        if (i)mp[a[i]]++;

        for (int j = 1; j <= c2; j++)
        {
            mp[b[j]]++;

            cur[i][j] = cur[i][j - 1] + 1;

            if (mp[b[j]] % k == 0)
            {
                cur[i][j] -= k;
            }
        }

        for (int j = 1; j <= c2; j++)
        {
            mp[b[j]]--;
        }
    }

    l = k, r = c1 + c2;

    while (l < r)
    {
        mid = (l + r) >> 1;

        if (check(mid))r = mid;  // 至少
        else l = mid + 1;
    }

    cout << l << endl;
}

int main()
{
    int t = 1;

    cin >> t;

    while (t--)solve();

    return 0;
}
```
