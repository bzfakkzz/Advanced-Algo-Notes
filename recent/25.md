[RC-u4 Tree Tree 的 - 2025年睿抗机器人开发者大赛CAIP-编程技能赛（省赛）-RoboCom 世界机器人开发者大赛-本科组](https://pintia.cn/problem-sets/1944703473372774400/exam/problems/type/7?problemSetProblemId=1944703473406328834)



1. 环

2. $\le2$节点的链



遍历所有节点，dfs更新ans1，ans2



```cpp
void dfs(int num, int cnt, int cur)
{
    for(auto u:g[cur])
    {
        if(!st[u])
        {
            st[u]=true;

            dfs(num, cnt+1, u);

            st[u]=false;
        }
        else if(u==num)
        {
            if(ans1<cnt)ans2=ans1,ans2=cnt;
            else if(ans2<cnt&&ans1!=cnt)ans2=cnt;  // 相同大小的只算一个环
        }
    }
}

for(int i=1;i<=n;i++)
{
    st[i]=true;

    dfs(i,1,i);

    st[i]=false;
}
```



```cpp
#include <bits/stdc++.h>

#define x first
#define y second
#define pii pair<int,int>

using namespace std;

const int N = 11;

int n, m;
int u, v;
int uu, vv;
int ans1, ans2;
bool st[N];
vector<int>g[N];

void dfs(int num, int cnt, int cur)
{
	for (auto u : g[cur])
	{
		if (!st[u])
		{
			st[u] = true;

			dfs(num, cnt + 1, u);

			st[u] = false;
		}
		else if (u == num)
		{
			if (cnt > ans1)
			{
				ans2 = ans1;
				ans1 = cnt;
			}
			else if (cnt > ans2 && cnt != ans1)ans2 = cnt;
		}
	}
}

void solve()
{
	cin >> n >> m;

	ans1 = ans2 = 0;

	for (int i = 1; i <= n; i++)st[i] = false;

	for (int i = 1; i <= n; i++)g[i].clear();

	for (int i = 1; i <= m; i++)
	{
		cin >> u >> v;

		g[u].emplace_back(v);
		g[v].emplace_back(u);
	}

	if (m == 0)ans1 = 1;
	else ans1 = 2, ans2 = 1;

	for (int i = 1; i <= n; i++)
	{
		st[i] = true;

		dfs(i, 1, i);

		st[i] = false;
	}

	cout << ans1 << " " << ans2;

	cout << endl;
}

int main()
{
	int t;

	cin >> t;

	while (t--)
	{
		solve();
	}

	return 0;
}
```




