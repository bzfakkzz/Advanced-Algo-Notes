[L2-011 玩转二叉树 - 团体程序设计天梯赛-练习集 (pintia.cn)](https://pintia.cn/problem-sets/994805046380707840/exam/problems/994805065406070784?type=7&page=1)



分析：



中序：左根右

前序：根左右

通过它们建树，镜面翻转只需要先左后右——>先右后左



```cpp
typedef struct Tree
{
    int data;

    Tree* l;
    Tree* r;
}* tree;

tree create(int l1,int r1,int l2,int r2)
{
    tree root=new Tree;

    root->data=p2[l2];

    root->l=root->r=NULL;

    int cur=l1;

    while(p1[cur]!=p2[l2])cur++;

    int cnt=cur-l1;

    if(cur!=l1)root->l=create(l1,cur-1,l2+1,l2+cur);
    if(cur!=r1)root->r=create(cur+1,r1,l2+cur+1,r2);

    return root;
}

void vis(tree root)
{
    queue<tree>q;

    if(root)q.push(root);

    tree t;

    while(!q.empty())
    {
        t=q.top();

        q.pop();

        cout<<t->data;

        if(t->r)q.push(t->r); if(t->l)q.push(t->l);

        if(q.empty())break;

        cout<<' ';
    }
}

void solve()
{
    cin>>n;

    for(int i=1;i<=n;i++)cin>>p1[i];
    for(int i=1;i<=n;i++)cin>>p2[i];

    tree root=create(1,n,1,n);

    vis(root);
}
```



```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 40;

typedef struct Tree
{
	int data;

	Tree* l;
	Tree* r;
}*tree;

int n;
int p1[N], p2[N];
vector<int>ans;

tree get(int l1, int r1, int l2, int r2)
{
	tree root = new Tree;

	root->data = p2[l2];

	root->l = root->r = NULL;

	int cur = l1;

	while (p1[cur] != p2[l2])cur++;

	int cnt = cur - l1;

	if (cur != l1)root->l = get(l1, cur - 1, l2 + 1, l2 + cnt);

	if (cur != r1)root->r = get(cur + 1, r1, l2 + cnt + 1, r2);

	return root;
}

void vis(tree root)
{
	queue<tree>q;

	if (root)q.push(root);

	tree t;

	while (!q.empty())
	{
		t = q.front();

		q.pop();

		ans.push_back(t->data);

		if (t->r)q.push(t->r);

		if (t->l)q.push(t->l);
	}
}

int main()
{
	cin >> n;

	for (int i = 1; i <= n; i++)cin >> p1[i];
	for (int i = 1; i <= n; i++)cin >> p2[i];

	tree root = get(1, n, 1, n);

	vis(root);

	for (int i = 0; i < ans.size() - 1; i++)cout << ans[i] << ' ';

	cout << ans.back();
	
	return 0;
}
```





[L2-006 树的遍历 - 团体程序设计天梯赛-练习集 (pintia.cn)](https://pintia.cn/problem-sets/994805046380707840/exam/problems/994805069361299456?type=7&page=1)



给定后序遍历和中序遍历，问层序遍历



分析：



从头开始建树，

后序是左右根，中序是左根右，

最后一个结点一定是根，

通过根节点中序找到左子树结点总数，

递归建树



```cpp
typedef struct Tree  // 定义struct Tree*为tree，结点指针
{
    int data;

    Tree* l;
    Tree* r;
}*tree;

tree build(int l1,int r1,int l2,int r2)
{
    tree root=new struct Tree;

    root->data=p1[r1];
    root->l=root->r=NULL;

    int cur=l2;

    while(p2[cur]!=p1[r1])cur++;  // 找左子树根节点数目

    int cnt=cur-l2;

    if(cur!=l2)  // 建左子树，注意略过根节点
    {
        root->l=build(l1,l1+cnt-1,l2,l2+cnt-1);
    }

    if(cur!=r2)  // 建右子树
    {
        root->r=build(l1+cnt,r1-1,l2+cnt+1,r2);
    }
}

void vis(tree root)
{
    queue<tree>q;

    if(root)q.push(root);

    while(!q.empty())
    {
        tree t=q.front();

        cout<<t->data;

        q.pop();

        if(t->l)q.push(t->l);

        if(t->r)q.push(t->r);

        if(q.empty())break;

        cout<<' ';
    }
}

int main()
{
    cin>>n;

    for(int i=1;i<=n;i++)cin>>p1[i];

    for(int i=1;i<=n;i++)cin>>p2[i];

    tree root=build(1,n,1,n);

    vis(root);

    return 0;
}
```



```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 40;

typedef struct Tree
{
    int data;

    Tree* l;
    Tree* r;
}*tree;  // 指向Tree的指针

int n;
int pos[N], in[N];

tree create(int l1, int r1, int l2, int r2)
{
    tree root = new struct Tree;

    root->data = pos[r1];  // 根节点

    root->l = root->r = NULL;

    int cur = l2;  // 找到左子树结点数目

    while (in[cur] != pos[r1])cur++;

    int p = cur - l2;  // 左子树结点数目

    if (cur != l2)root->l = create(l1, l1 + p - 1, l2, cur - 1);  // 建立左子树

    if (cur != r2)root->r = create(l1 + p, r1 - 1, cur + 1, r2);  // 建立右子树

    return root;
}

void vis(tree root)
{
    queue<tree>q;  // 指向节点的指针

    if (root)q.push(root);

    while (!q.empty())
    {
        root = q.front();

        q.pop();

        cout << root->data;

        if (root->l)q.push(root->l);

        if (root->r)q.push(root->r);

        if (!q.empty())cout << ' ';  // 层序遍历不是最后一个
    }
}

int main()
{
    cin >> n;

    for (int i = 1; i <= n; i++)cin >> pos[i];

    for (int i = 1; i <= n; i++)cin >> in[i];

    tree root = create(1, n, 1, n);

    vis(root);

    return 0;
}
```





[Problem - F - Codeforces](https://codeforces.com/contest/1950/problem/F)



给定一棵树的二叉节点数，单叉节点树，叶节点数，

问建树的最少深度为多少



分析：



建树层数最少一定是类完全二叉树，这样一层的节点数最多，

模拟建树，用queue存放当前节点的深度，

从二叉开始建，之后建单叉，每次用cur更新ans



```cpp
void solve()
{
    cin>>a>>b>>c;

    if(2*a+b+1!=a+b+c)puts("-1"); // 除了根节点，每个分叉都连了一个节点
    else
    {
        queue<int>q;

        q.push(0); ans=0;

        while(!q.empty())
        {
            cur=q.front(); q.pop();

            ans=max(ans,cur);

            if(a){q.push(cur+1),q.push(cur+1); a--;}  // 从当前节点得到下一层节点深度
            else if(b){q.push(cur+1); b--;}
        }

        cout<<ans<<endl;
    }
}
```

<img title="" src="pictures_acm/1950f1.png" alt="" data-align="center" style="zoom:67%;">

```cpp
#include <bits/stdc++.h>
#include <functional>
 
#define alls(a) a.begin(),a.end()
#define emb emplace_back
#define pub push_back
#define pob pop_back
#define puf push_front
#define pof pop_front
#define fi first
#define se second
#define No puts("No")
#define Yes puts("Yes")
#define NO puts("NO")
#define YES puts("YES")
 
using namespace std;
typedef long long ll;
//typedef __int128 lll; // G++(32位)不支持
typedef unsigned long long ull;
typedef pair<int, int> pii;
 
const int N = 2e5 + 10;
const int mo = 1e9 + 7;
const int inf = 2e9 + 10;
 
int a, b, c;
int cur, ans;
 
void solve()
{
    cin >> a >> b >> c;
 
    if (2 * a + b + 1 != a + b + c)puts("-1");
    else
    {
        queue<int>q;
 
        q.push(0);
 
        ans = 0;
 
        while (!q.empty()) // q存放当前节点对应的层数
        {
            cur = q.front(); q.pop();  // 当前节点层数
 
            ans = max(ans, cur);
 
            if (a)  // 先将二叉节点连子节点，这样层数最少
            {
                q.push(cur + 1), q.push(cur + 1);  // 子节点的层数
 
                a--;
            }
            else if (b)
            {
                q.push(cur + 1);
 
                b--;
            }
        }

        cout << ans << endl;
    }
}
 
int main()
{
    int t;
 
    cin >> t;
 
    //t = 1;
 
    while (t--)solve();
 
    return 0;
}
```
