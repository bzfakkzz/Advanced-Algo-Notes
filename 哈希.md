## 哈希：

$O(1)$



用h1映射初始值，h2数组存储当前位置值的数目，h3数组存放对应元素，

哈希作用类似map，

将当前多个元素值进行离散`tem=x*p+y`，区分`x,y`的地位，

映射为哈希值，依赖哈希值进行随机储存，高效查找



map   $O(logN)$



哈希常数（质数）：

1313131313，99999997





[P2038 - [蓝桥杯2022初赛] 扫雷 - New Online Judge (ecustacm.cn)](http://oj.ecustacm.cn/problem.php?id=2038)



分析：



通过h1数组存放每个哈希值对应的`(x,y)`离散值，

找到哈希值，

h2数组存放`(x,y)`位置存放的炸弹个数，

h3数组存放`(x,y)`的爆炸范围，

st数组存放当前位置是否被搜过



对于每个引爆位置进行dfs深搜，

如果当前炸弹爆炸，就继续对当前炸弹进行dfs深搜



哈希+dfs，$O(100\times 5\cdot 10^4)$



```cpp
const int p=1e9+9;
const int M=9999997;  // 冲突最小的质数

int get(ll x)  // 得到哈希值
{
    int w=(x%M+M)%M;  // 哈希常数映射

    while(h1[w]!=-1&&h1[w]!=x)  // 1. 没有被找过  2. 存过但是没有被找到
    {
        w++; if(w==M)w=0;
    }

    return w;
}

bool check(int x,int y,int xx,int yy,int r)  // 判断是否在爆炸范围
{
    return (1ll*x-xx)*(x-xx)+(1ll*y-yy)*(y-yy)<=1ll*r*r;
}

void dfs(int x,int y,int r)
{
    int dx,dy;

    for(int i=-r;i<=r;i++)  // 枚举dx，dy
    {
        for(int j=-r;j<=r;j++)
        {
            dx=x+i,dy=y+j;

            tem=(1ll*dx*p+y);

            w=get(tem);  // 得到哈希值

            if(h2[w]&&!st[w]&&check(x,y,dx,dy,r))  // 1. 有炸弹 2. 没有被找过 3. 在爆炸范围内
            {
                st[w]=true;

                ans+=h2[w];  // 加上爆炸的数量

                dfs(dx,dy,h3[w]); // 当前炸弹被引爆了
            }
        }
    }
}

void solve()
{
    cin>>n>>m;

    memset(h1,-1,sizeof(h1));  // 初始化标记为-1，意为没用过

    for(int i=1;i<=n;i++)
    {
        cin>>x>>y>>r;

        tem=(1ll*x*p+y);  // 指数用来表示(x,y)地位

        w=get(tem);

        h1[w]=tem;
        h2[w]++;
        h3[w]=max(r,h3[w]);  // 爆炸范围存最大值
    }

    for(int i=1;i<=m;i++)
    {
        cin>>x>>y>>r; dfs(x,y,r);  // 开始引爆
    }

    cout<<ans<<endl;
}
```



```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int p = 1e9 + 10;
const int N = 9999997;  // 13131313

int n, m;
int x, y, r;
int ans;
ll tem;
ll h1[N];
int h2[N], h3[N], st[N];

// h1用于记录当前位置对应的离散数值，初始值-1
// h2用于记录炸弹数量
// h3用于记录炸弹爆炸半径
// st数组用于记录当前炸弹是否被搜过

ll get(int x, int y)  // 原始离散数值
{
	return 1ll * x * p + y;
}

int find(ll x)  // 找到离散数值对应的哈希值（合法位置）
{
	int cur = (x % N + N) % N;  // 映射初始值

	while (h1[cur] != -1 && h1[cur] != x)  // 寻找目标位置
	{
		cur++;

		if (cur == N)cur = 0;
	}

	return cur;
}

bool check(int x1, int y1, int x2, int y2, int r)
{
	return 1ll * (x1 - x2) * (x1 - x2) + 1ll * (y1 - y2) * (y1 - y2) <= 1ll * r * r;
}

void dfs(int x, int y, int r)
{
	int dx, dy;

	for (int i = -r; i <= r; i++)
	{
		for (int j = -r; j <= r; j++)
		{
			dx = x + i, dy = y + j;

			tem = get(dx, dy);  // 得到原始离散数值

			// 1. 当前位置有炸弹
			// 2. 当前位置能被引爆
			// 3. 当前位置没有被爆过

			if (h2[find(tem)] && check(dx, dy, x, y, r) && !st[find(tem)])
			{
				ans += h2[find(tem)];

				st[find(tem)] = true;

				dfs(dx, dy, h3[find(tem)]);  // 当前炸弹爆炸了能引爆周边炸弹
			}
		}
	}
}

void solve()
{
	cin >> n >> m;

	memset(h1, -1, sizeof(h1));  // 初始化哈希映射值

	for (int i = 1; i <= n; i++)
	{
		cin >> x >> y >> r;

		tem = get(x, y);  // 得到离散数值

		h1[find(tem)] = tem;  // 记录当前位置存放的离散数值

		h2[find(tem)]++;

		h3[find(tem)] = max(r, h3[find(tem)]);  // 保留当前位置炸弹能爆炸的最大范围
	}

	for(int i=1;i<=m;i++)
	{
		cin >> x >> y >> r;

		dfs(x, y, r);  // 引爆炸弹
	}

	cout << ans << endl;
}

int main()
{
	solve();

	return 0;
}
```
