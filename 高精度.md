## 高精度除法：



从最高位开始，每次都除当前的d，

如果当前cur为0，就从前往后取d的位数，%=x，并且向后走d的位数，

否则就将cur连到当前a[i]之前，cur*=10，cur+=a[i]，cur%=x





[0拼数字 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/17111/learning/)



分析：



打表得出，3在2前满足要求的结果更多，

用prev_permutation将数组字典序慢慢变小，

如果check满足要求就直接输出



```cpp
bool check()
{
    cur=0;

    for(int i=1;i<=n+m;i++)
    {
        if(cur==0)  // 当前cur是0，后移d位
        {
            cur=(a[i]*1000+a[i+1]*100+a[i+2]*10+a[i+3])%2023;

            cur%=2023;

            i+=3;
        }
        else  // 当前位非0，直接接在a[i]前
        {
            cur*=10; cur+=a[i]; cur%=2023;
        }
    }

    if(cur%2023==0)return true; else return false;
}

void solve()
{
    cin>>n>>m;

    for(int i=1;i<=m;i++)a[i]=3;
    for(int i=m+1;i<=n+m;i++)a[i]=2;

    bool f=false;

    do
    {
        if(check()){f=true; for(int i=1;i<=n+m;i++)cout<<a[i]; break;}
    }while(prev_permutation(a+1,a+n+m+1));

    if(!f)cout<<-1<<endl;
}
```





```cpp
#include <bits/stdc++.h>

using namespace std;

const int d=2023,N=2e6+10;

int n,m;
int a[N];

bool check()
{
    int cur=0;

    for(int i=1;i<=n+m;i++)
    {
        if(cur==0)
        {
            cur=a[i]*1000+a[i+1]*100+a[i+2]*10+a[i+3];

            cur%=2023;

            i+=3;
        }
        else
        {
            cur*=10;

            cur+=a[i];

            cur%=2023;
        }
    }

    if(cur%2023==0)return true;
    else return false;
}

int main()
{
    bool f=false;

    cin>>n>>m;

    for(int i=1;i<=m;i++)a[i]=3;

    for(int i=m+1;i<=n+m;i++)a[i]=2;

    do
    {
        if(check())
        {
            for(int i=1;i<=n+m;i++)cout<<a[i];

            f=true;

            break;
        }
    }while(prev_permutation(a+1,a+n+m+1));

    if(f==false)puts("-1");

    return 0;
}
```


